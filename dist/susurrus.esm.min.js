function t(t,e){return{x:t.x1+e*(t.x2-t.x1),y:t.y1+e*(t.y2-t.y1)}}class e{constructor(t,e,i,s){this.x1=t,this.y1=e,this.x2=i,this.y2=s}getIntersectionInformation(e){const i=e.x1,s=e.y1,r=e.x2,n=e.y2,a=(this.x1-this.x2)*(s-n)-(this.y1-this.y2)*(i-r);if(0===a)return null;let h=(this.x1-i)*(s-n)-(this.y1-s)*(i-r);const o=h/a;h=(this.x1-this.x2)*(this.y1-s)-(this.y1-this.y2)*(this.x1-i);const l=-h/a;return{t:o,u:l,intersected:0<=o&&o<=1&&0<=l&&l<=1,convergence:t(this,o)}}intersects(t){const e=this.getIntersectionInformation(t);return null!==e&&e.intersected}}function i(t,e,i,s,r){return s+(r-s)*(t-e)/(i-e)}function s(t,e,i){return t+i*(e-t)}function r(t,e,i){return(1-i)*t+i*e}var n=Object.freeze({__proto__:null,remapRange:i,lerp:s,lerpPrecise:r,log:function(t,e){switch(e){case 2:return Math.log(t)/Math.LN2;case 10:return Math.log(t)/Math.LN10;default:return Math.log(t)/Math.log(e)}}});class a{constructor(t,e){this.x=t,this.y=e}static get ZERO(){return new a(0,0)}static get ONE(){return new a(1,1)}static get UNIT_X(){return new a(1,0)}static get UNIT_Y(){return new a(0,1)}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x**2+this.y**2}normalize(){const t=1/this.length();return this.x*=t,this.y*=t,this}copy(t){this.x=t.x,this.y=t.y}clone(){return new a(this.x,this.y)}toArray(){return[this.x,this.y]}toString(){return`(${this.x}, ${this.y})`}static distanceSquared(t,e){return(t.x-e.x)**2+(t.y-e.y)**2}static distance(t,e){return Math.sqrt(a.distanceSquared(t,e))}static dot(t,e){return t.x*e.x+t.y*e.y}static lerp(t,e,i){const r=s(t.x,e.x,i),n=s(t.y,e.y,i);return new a(r,n)}static lerpPrecise(t,e,i){const s=r(t.x,e.x,i),n=r(t.y,e.y,i);return new a(s,n)}static polarToCartesian(t,e){return new a(t*Math.cos(e),t*Math.sin(e))}static fromAngle(t){return a.polarToCartesian(1,t)}static random(){return a.fromAngle(Math.random()*Math.PI*2)}static add(t,e){const i=t.x+e.x,s=t.y+e.y;return new a(i,s)}static subtract(t,e){const i=t.x-e.x,s=t.y-e.y;return new a(i,s)}static multiply(t,e){const i=t.x*e.x,s=t.y*e.y;return new a(i,s)}static divide(t,e){const i=t.x/e.x,s=t.y/e.y;return new a(i,s)}static addScalar(t,e){const i=t.x+e,s=t.y+e;return new a(i,s)}static subtractScalar(t,e){const i=t.x-e,s=t.y-e;return new a(i,s)}static multiplyScalar(t,e){const i=t.x*e,s=t.y*e;return new a(i,s)}static divideScalar(t,e){const i=t.x/e,s=t.y/e;return new a(i,s)}static transform(t,e){const i=t.x*e.data[0]+t.y*e.data[4]+e.data[12],s=t.x*e.data[1]+t.y*e.data[5]+e.data[13];return new a(i,s)}}class h{constructor(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y-this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top>t.bottom&&this.bottom<t.top}completelyWithin(t){return this.left>=t.left&&this.right<=t.right&&this.bottom>=t.bottom&&this.top<=t.top}getResolution(t){const i=[new a(this.left,this.top),new a(this.right,this.top),new a(this.right,this.bottom),new a(this.left,this.bottom)],s=[new e(i[0].x,i[0].y,i[1].x,i[1].y),new e(i[1].x,i[1].y,i[2].x,i[2].y)],r=[new a(t.left,t.top),new a(t.right,t.top),new a(t.right,t.bottom),new a(t.left,t.bottom)];return o({vertices:i,edges:s},{vertices:r,edges:[new e(r[0].x,r[0].y,r[1].x,r[1].y),new e(r[1].x,r[1].y,r[2].x,r[2].y)]})}}function o(t,e){const i=l(t.vertices),s=l(e.vertices);if(!i.intersects(s))return new a(0,0);const r=c(t,e),n=c(e,t);if(null===r||null===n)return new a(0,0);const h=r.overlap<n.overlap?r:n,o=new a(-(h.edge.y2-h.edge.y1),h.edge.x2-h.edge.x1),d=o.length(),u=Math.acos(a.dot(o,new a(1,0))/d),w=Math.round(d*Math.cos(u)),p=Math.round(d*Math.sin(u)),f=i.left>s.left?1:-1,g=i.bottom>s.bottom?1:-1,y=0===w?0:h.overlap/w*f,m=0===p?0:h.overlap/p*g;return new a(y,m)}function l(t){let e=t[0].x,i=e,s=t[0].y,r=s;for(let n=1;n<t.length;n++)e=Math.min(e,t[n].x),i=Math.max(i,t[n].x),s=Math.min(s,t[n].y),r=Math.max(r,t[n].y);return new h(e,r,i-e,r-s)}function c(t,i){let s=new e(0,0,0,0),r=Number.MAX_SAFE_INTEGER;for(let e=0;e<t.edges.length;e++){const n=new a(-(t.edges[e].y2-t.edges[e].y1),t.edges[e].x2-t.edges[e].x1);let h=a.dot(t.vertices[0],n),o=h;for(let e=1;e<t.vertices.length;e++){const i=a.dot(t.vertices[e],n);h=Math.min(h,i),o=Math.max(o,i)}let l=a.dot(i.vertices[0],n),c=l;for(let t=1;t<i.vertices.length;t++){const e=a.dot(i.vertices[t],n);l=Math.min(l,e),c=Math.max(c,e)}const d=Math.min(o,c)-Math.max(h,l);if(d<r&&(r=d,s=t.edges[e]),c<h||o<l)return null}return{edge:s,overlap:r}}var d,u,w,p=Object.freeze({__proto__:null,getResolution:o}),f=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},g=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class y{constructor(t,e,i){d.set(this,void 0),u.set(this,void 0),w.set(this,void 0),f(this,d,t),f(this,u,e),f(this,w,new Array(g(this,d)*g(this,u)).fill(0)),void 0!==i&&this.setData(i)}get rows(){return g(this,d)}get columns(){return g(this,u)}get data(){return g(this,w)}get(t,e){return this.data[this.columns*e+t]}setData(t){if(t.length!==this.rows*this.columns)throw new TypeError("The given data does not match the dimensions of the matrix.");f(this,w,t.slice(0))}set(t,e,i){g(this,w)[this.columns*e+t]=i}transpose(){const t=new Array(this.rows*this.columns).fill(0),e=this.columns,i=this.rows;for(let s=0;s<e;s++)for(let e=0;e<i;e++)t[i*s+e]=this.data[this.columns*e+s];f(this,w,t)}toString(){let t="";for(let e=0;e<g(this,w).length;e+=this.columns){t+="("+g(this,w)[e];for(let i=1;i<this.columns;i++)t+=" "+g(this,w)[e+i];t+=")",e!==g(this,w).length-this.columns&&(t+=" ")}return t}static add(t,e){if(t.rows!==e.rows||t.columns!==e.columns)throw new TypeError("Both matrices are not the same size; cannot perform operation.");const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]+=e.data[s];return new y(t.rows,t.columns,i)}static subtract(t,e){if(t.rows!==e.rows||t.columns!==e.columns)throw new TypeError("Both matrices are not the same size; cannot perform operation.");const i=t.data.slice(0);for(let s=0;s<t.rows*t.columns;s++)i[s]-=e.data[s];return new y(t.rows,e.rows,i)}static multiply(t,e){if(t.columns!==e.rows)throw new TypeError(`Matrix b must have ${t.columns} rows; cannot multiply matrices.`);const i=new y(t.rows,e.columns);for(let s=0;s<t.rows;s++)for(let r=0;r<e.columns;r++){let n=0;for(let i=0;i<t.columns;i++)n+=t.get(i,s)*e.get(r,i);i.set(r,s,n)}return i}static addScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]+=e;return new y(t.rows,t.columns,i)}static subtractScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]-=e;return new y(t.rows,t.columns,i)}static multiplyScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]*=e;return new y(t.rows,t.columns,i)}static divideScalar(t,e){const i=1/e;return y.multiplyScalar(t,i)}}d=new WeakMap,u=new WeakMap,w=new WeakMap;class m{constructor(t,e,i){this.x=t,this.y=e,this.z=i}static get ZERO(){return new m(0,0,0)}static get ONE(){return new m(1,1,1)}static get UNIT_X(){return new m(1,0,0)}static get UNIT_Y(){return new m(0,1,0)}static get UNIT_Z(){return new m(0,0,1)}static get LEFT(){return new m(-1,0,0)}static get UP(){return new m(0,1,0)}static get RIGHT(){return new m(1,0,0)}static get DOWN(){return new m(0,-1,0)}static get FORWARD(){return new m(0,0,-1)}static get BACKWARD(){return new m(0,0,1)}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x**2+this.y**2+this.z**2}normalize(){const t=1/this.length();return this.x*=t,this.y*=t,this.z*=t,this}copy(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(){return new m(this.x,this.y,this.z)}toArray(){return[this.x,this.y,this.z]}toString(){return`(${this.x}, ${this.y}, ${this.z})`}static distanceSquared(t,e){return(t.x-e.x)**2+(t.y-e.y)**2+(t.z-e.z)**2}static distance(t,e){return Math.sqrt(m.distanceSquared(t,e))}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static lerp(t,e,i){const r=s(t.x,e.x,i),n=s(t.y,e.y,i),a=s(t.z,e.z,i);return new m(r,n,a)}static lerpPrecise(t,e,i){const s=r(t.x,e.x,i),n=r(t.y,e.y,i),a=r(t.z,e.z,i);return new m(s,n,a)}static sphericalToCartesian(t,e,i){return new m(t*Math.sin(i)*Math.cos(e),t*Math.sin(i)*Math.sin(e),t*Math.cos(i))}static cross(t,e){const i=t.y*e.z-e.y*t.z,s=t.z*e.x-e.z*t.x,r=t.x*e.y-e.x*t.y;return new m(i,s,r)}static add(t,e){const i=t.x+e.x,s=t.y+e.y,r=t.z+e.z;return new m(i,s,r)}static subtract(t,e){const i=t.x-e.x,s=t.y-e.y,r=t.z-e.z;return new m(i,s,r)}static multiply(t,e){const i=t.x*e.x,s=t.y*e.y,r=t.z*e.z;return new m(i,s,r)}static divide(t,e){const i=t.x/e.x,s=t.y/e.y,r=t.z/e.z;return new m(i,s,r)}static addScalar(t,e){const i=t.x+e,s=t.y+e,r=t.z+e;return new m(i,s,r)}static subtractScalar(t,e){const i=t.x-e,s=t.y-e,r=t.z-e;return new m(i,s,r)}static multiplyScalar(t,e){const i=t.x*e,s=t.y*e,r=t.z*e;return new m(i,s,r)}static divideScalar(t,e){const i=t.x/e,s=t.y/e,r=t.z/e;return new m(i,s,r)}static transform(t,e){const i=t.x*e.data[0]+t.y*e.data[4]+t.z*e.data[8]+e.data[12],s=t.x*e.data[1]+t.y*e.data[5]+t.z*e.data[9]+e.data[13],r=t.x*e.data[2]+t.y*e.data[6]+t.z*e.data[10]+e.data[14];return new m(i,s,r)}}var v,E,b,T=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},x=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class M{constructor(t){v.set(this,void 0),E.set(this,void 0),b.set(this,void 0),T(this,v,4),T(this,E,4),T(this,b,new Array(x(this,v)*x(this,E)).fill(0)),void 0!==t&&this.setData(t)}get rows(){return x(this,v)}get columns(){return x(this,E)}get data(){return x(this,b)}static get IDENTITY(){return new M([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}setData(t){if(t.length!==x(this,v)*x(this,E))throw new TypeError("The given data does not match the dimensions of the matrix.");T(this,b,t.slice(0))}get(t,e){return x(this,b)[x(this,E)*e+t]}set(t,e,i){x(this,b)[x(this,E)*e+t]=i}transpose(){const t=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];t[0]=x(this,b)[0],t[1]=x(this,b)[4],t[2]=x(this,b)[8],t[3]=x(this,b)[12],t[4]=x(this,b)[1],t[5]=x(this,b)[5],t[6]=x(this,b)[9],t[7]=x(this,b)[13],t[8]=x(this,b)[2],t[9]=x(this,b)[6],t[10]=x(this,b)[10],t[11]=x(this,b)[14],t[12]=x(this,b)[3],t[13]=x(this,b)[7],t[14]=x(this,b)[11],t[15]=x(this,b)[15],T(this,b,t)}toString(){return`(${this.data[0]}, ${this.data[1]}, ${this.data[2]}, ${this.data[3]}) (${this.data[4]}, ${this.data[5]}, ${this.data[6]}, ${this.data[7]}) (${this.data[8]}, ${this.data[9]}, ${this.data[10]}, ${this.data[11]}) (${this.data[12]}, ${this.data[13]}, ${this.data[14]}, ${this.data[15]})`}static add(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]+=e.data[t];return new M(i)}static subtract(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]-=e.data[t];return new M(i)}static multiply(t,e){const i=new Array(16).fill(0);return i[0]=t.data[0]*e.data[0]+t.data[1]*e.data[4]+t.data[2]*e.data[8]+t.data[3]*e.data[12],i[1]=t.data[0]*e.data[1]+t.data[1]*e.data[5]+t.data[2]*e.data[9]+t.data[3]*e.data[13],i[2]=t.data[0]*e.data[2]+t.data[1]*e.data[6]+t.data[2]*e.data[10]+t.data[3]*e.data[14],i[3]=t.data[0]*e.data[3]+t.data[1]*e.data[7]+t.data[2]*e.data[11]+t.data[3]*e.data[15],i[4]=t.data[4]*e.data[0]+t.data[5]*e.data[4]+t.data[6]*e.data[8]+t.data[7]*e.data[12],i[5]=t.data[4]*e.data[1]+t.data[5]*e.data[5]+t.data[6]*e.data[9]+t.data[7]*e.data[13],i[6]=t.data[4]*e.data[2]+t.data[5]*e.data[6]+t.data[6]*e.data[10]+t.data[7]*e.data[14],i[7]=t.data[4]*e.data[3]+t.data[5]*e.data[7]+t.data[6]*e.data[11]+t.data[7]*e.data[15],i[8]=t.data[8]*e.data[0]+t.data[9]*e.data[4]+t.data[10]*e.data[8]+t.data[11]*e.data[12],i[9]=t.data[8]*e.data[1]+t.data[9]*e.data[5]+t.data[10]*e.data[9]+t.data[11]*e.data[13],i[10]=t.data[8]*e.data[2]+t.data[9]*e.data[6]+t.data[10]*e.data[10]+t.data[11]*e.data[14],i[11]=t.data[8]*e.data[3]+t.data[9]*e.data[7]+t.data[10]*e.data[11]+t.data[11]*e.data[15],i[12]=t.data[12]*e.data[0]+t.data[13]*e.data[4]+t.data[14]*e.data[8]+t.data[15]*e.data[12],i[13]=t.data[12]*e.data[1]+t.data[13]*e.data[5]+t.data[14]*e.data[9]+t.data[15]*e.data[13],i[14]=t.data[12]*e.data[2]+t.data[13]*e.data[6]+t.data[14]*e.data[10]+t.data[15]*e.data[14],i[15]=t.data[12]*e.data[3]+t.data[13]*e.data[7]+t.data[14]*e.data[11]+t.data[15]*e.data[15],new M(i)}static addScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]+=e;return new M(i)}static subtractScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]-=e;return new M(i)}static multiplyScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]*=e;return new M(i)}static divideScalar(t,e){const i=1/e;return M.multiplyScalar(t,i)}static createRotationX(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[5]=Math.cos(t),e[6]=Math.sin(t),e[9]=-Math.sin(t),e[10]=Math.cos(t),new M(e)}static createRotationY(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[0]=Math.cos(t),e[2]=-Math.sin(t),e[8]=Math.sin(t),e[10]=Math.cos(t),new M(e)}static createRotationZ(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[0]=Math.cos(t),e[1]=Math.sin(t),e[4]=-Math.sin(t),e[5]=Math.cos(t),new M(e)}static createTranslation(t,e,i){const s=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return s[12]=t,s[13]=e,s[14]=i,new M(s)}static createScale(t,e,i){const s=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return s[0]=t,s[5]=e,s[10]=i,new M(s)}static createOrthographic(t,e,i,s){const r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],n=1/(s-i);return r[0]=2/t,r[5]=2/e,r[10]=-2*n,r[14]=-(s+i)*n,new M(r)}static createOrthographicOffCenter(t,e,i,s,r,n){const a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],h=1/(e-t),o=1/(s-i),l=1/(n-r);return a[0]=2*h,a[5]=2*o,a[10]=-2*l,a[12]=-(e+t)*h,a[13]=-(s+i)*o,a[14]=-(n+r)*l,a[15]=1,new M(a)}static createPerspective(t,e,i,s){const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=1/(s-i);return r[0]=2*i/t,r[5]=2*i/e,r[10]=-(s+i)*n,r[11]=-1,r[14]=-2*s*i*n,new M(r)}static createPerspectiveOffCenter(t,e,i,s,r,n){const a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],h=1/(e-t),o=1/(s-i),l=1/(n-r);return a[0]=2*r*h,a[5]=2*r*o,a[8]=(e+t)*h,a[9]=(s+i)*o,a[10]=-(n+r)*l,a[11]=-1,a[14]=-2*n*r*l,new M(a)}static createLookAt(t,e,i){const s=m.subtract(t,e).normalize(),r=m.cross(i,s).normalize(),n=m.cross(s,r),a=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return a[0]=r.x,a[1]=n.x,a[2]=s.x,a[4]=r.y,a[5]=n.y,a[6]=s.y,a[8]=r.z,a[9]=n.z,a[10]=s.z,a[12]=-m.dot(r,t),a[13]=-m.dot(n,t),a[14]=-m.dot(s,t),new M(a)}}v=new WeakMap,E=new WeakMap,b=new WeakMap;var _,k=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},A=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function S(t){return function(){var e=t+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296}}class W{constructor(t){_.set(this,void 0),k(this,_,S(void 0!==t?Math.floor(t):Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)))}next(){return A(this,_).call(this)}range(t,e){if(e<t)throw new TypeError("The 'maxValue' parameter must be greater than 'minValue' parameter.");return t+Math.floor(A(this,_).call(this)*(e-t))}}_=new WeakMap;var P,R,O,L,I,z,N,B,D,G,U,C,j,F=Object.freeze({__proto__:null,roll:function(t){return!(t<=0)&&(t>=1||Math.random()<=t)},gaussian:function(t,e){const i=1-Math.random(),s=1-Math.random();return t+e*(Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*s))}}),V=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},X=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function $(t,e,i){const s=M.multiply;return s(s(t,e),i)}!function(t){t[t.None=0]="None",t[t.Orthographic=1]="Orthographic",t[t.Perspective=2]="Perspective"}(j||(j={}));class q{constructor(){P.set(this,void 0),R.set(this,void 0),O.set(this,void 0),L.set(this,void 0),I.set(this,void 0),z.set(this,void 0),N.set(this,void 0),B.set(this,void 0),D.set(this,void 0),G.set(this,void 0),U.set(this,void 0),C.set(this,void 0),V(this,P,m.ZERO),V(this,R,new m(X(this,P).x,X(this,P).y,X(this,P).z+1)),V(this,O,m.UP),V(this,L,0),V(this,I,0),V(this,z,0),V(this,N,0),V(this,B,j.None),V(this,D,M.IDENTITY),V(this,G,M.createLookAt(X(this,R),X(this,P),X(this,O))),V(this,U,M.IDENTITY),V(this,C,M.IDENTITY)}get wvp(){return X(this,C)}get bounds(){return new h(X(this,R).x,X(this,R).y,X(this,z),X(this,N))}createOrthographic(t,e,i,s){return V(this,z,t),V(this,N,e),V(this,L,void 0===i?0:i),V(this,I,void 0===s?0:s),V(this,B,j.Orthographic),V(this,U,M.createOrthographic(X(this,z),X(this,N),X(this,L),X(this,I))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}createPerspective(t,e,i,s){return V(this,z,t),V(this,N,e),V(this,L,void 0===i?0:i),V(this,I,void 0===s?0:s),V(this,B,j.Perspective),V(this,U,M.createPerspective(X(this,z),X(this,N),X(this,L),X(this,I))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setDimensions(t,e){switch(V(this,z,t),V(this,N,e),X(this,B)){case j.Orthographic:V(this,U,M.createOrthographic(X(this,z),X(this,N),X(this,L),X(this,I)));break;case j.Perspective:V(this,U,M.createPerspective(X(this,z),X(this,N),X(this,L),X(this,I)))}return V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setPosition(t,e,i){return X(this,R).x=t,X(this,R).y=e,X(this,R).z=i,V(this,G,M.createLookAt(X(this,R),X(this,P),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setTarget(t,e,i){return X(this,P).x=t,X(this,P).y=e,X(this,P).z=i,V(this,G,M.createLookAt(X(this,R),X(this,P),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setUp(t,e,i){return X(this,O).x=t,X(this,O).y=e,X(this,O).z=i,V(this,G,M.createLookAt(X(this,R),X(this,P),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setWorld(t){return V(this,D,t),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}}P=new WeakMap,R=new WeakMap,O=new WeakMap,L=new WeakMap,I=new WeakMap,z=new WeakMap,N=new WeakMap,B=new WeakMap,D=new WeakMap,G=new WeakMap,U=new WeakMap,C=new WeakMap;class H{constructor(t,e){this.name=t,this.theater=e,Object.defineProperty(this,"name",{writable:!1}),Object.defineProperty(this,"theater",{writable:!1})}onEnter(){}onExit(){}}class Y{constructor(t,e,i){this.name=t,this.size=e,this.type=i,this.stride=-1,this.offset=-1,Object.defineProperty(this,"name",{writable:!1}),Object.defineProperty(this,"size",{writable:!1}),Object.defineProperty(this,"type",{writable:!1})}}const K={BYTE:5120,SHORT:5122,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FIXED:void 0,FLOAT:5126};Object.freeze(K);const Z={BYTE:1,SHORT:2,UNSIGNED_BYTE:1,UNSIGNED_SHORT:2,FIXED:void 0,FLOAT:4};Object.freeze(Z);class Q{constructor(t){this.elements=t;const e=function(t){let e=0,i=0,s=[];for(let r of t)switch(e+=r.size,s.push(i),r.type){case K.FLOAT:i+=Z.FLOAT*r.size;break;default:throw new TypeError("Unsupported attribute type.")}for(let e=0;e<t.length;e++)t[e].stride=i,t[e].offset=s[e];return{size:e,stride:i}}(this.elements);this.size=e.size,this.stride=e.stride,Object.defineProperty(this,"elements",{writable:!1}),Object.defineProperty(this,"size",{writable:!1}),Object.defineProperty(this,"stride",{writable:!1})}}function J(t,e,i){return function(t,e,i){const s=t.createProgram();if(null===s)throw new Error("Something went wrong; could not create WebGLProgram.");if(t.attachShader(s,e),t.attachShader(s,i),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS))throw new Error("An error occurred while initializing the shader program: "+t.getProgramInfoLog(s));return s}(t,it(t,t.VERTEX_SHADER,e),it(t,t.FRAGMENT_SHADER,i))}function tt(t,e,i,s){const r=t.createBuffer();if(null===r)throw new Error("Something went wrong; could not create WebGLBuffer.");return t.bindBuffer(e,r),t.bufferData(e,i,s),r}function et(t,e,i,s){t.bindBuffer(e,i),t.bufferSubData(e,0,s)}function it(t,e,i){const s=t.createShader(e);if(null===s)throw new TypeError(`'${e}' is not a valid WebGL shader type.`);if(t.shaderSource(s,i),t.compileShader(s),!t.getShaderParameter(s,t.COMPILE_STATUS)){const e=new Error("An error occurred will compiling the shader: "+t.getShaderInfoLog(s));throw t.deleteShader(s),e}return s}function st(t){return 0==(t&t-1)}const rt={VERTEX:0,INDEX:1};Object.freeze(rt);var nt,at=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ht=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class ot{constructor(t,e,i){nt.set(this,void 0),this.length=e,this.type=i,at(this,nt,t),this.data=null,this.buffer=null,Object.defineProperty(this,"length",{writable:!1}),Object.defineProperty(this,"type",{writable:!1})}setData(t){if(null===this.data||null===this.buffer)throw new Error("This buffer was not initialized correctly. Make sure the 'data' and 'buffer' properties are set..");if(null!=t){if(t.length>this.length)throw new TypeError(`Expected an array with ${this.length} element(s) or less.`);switch(this.data.set(t),this.type){case rt.VERTEX:!function(t,e,i){et(t,t.ARRAY_BUFFER,e,i)}(ht(this,nt).gl,this.buffer,this.data);break;case rt.INDEX:!function(t,e,i){et(t,t.ELEMENT_ARRAY_BUFFER,e,i)}(ht(this,nt).gl,this.buffer,this.data);break;default:throw new TypeError(`'${this.type}' is an invalid BufferType.`)}}}}nt=new WeakMap;var lt,ct,dt,ut,wt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},pt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class ft{constructor(t,e){switch(lt.set(this,void 0),ct.set(this,void 0),dt.set(this,void 0),ut.set(this,void 0),wt(this,lt,0),wt(this,ct,0),wt(this,dt,0),wt(this,ut,1),typeof t){case"number":wt(this,lt,this.validateValue(((16711680&t)>>16)/255)),wt(this,ct,this.validateValue(((65280&t)>>8)/255)),wt(this,dt,this.validateValue((255&t)/255));break;case"string":{let e=t.toLowerCase().trim();if(e="#"==e.substring(0,1)?e.substring(1):e,!/^[\da-f]{6}$/.test(e))throw new TypeError("The given string could not be parsed as a hexadecimal value.");const i=parseInt(e,16);wt(this,lt,this.validateValue(((16711680&i)>>16)/255)),wt(this,ct,this.validateValue(((65280&i)>>8)/255)),wt(this,dt,this.validateValue((255&i)/255));break}}void 0!==e&&this.multiply(this.validateValue(e))}get r(){return pt(this,lt)}set r(t){wt(this,lt,this.validateValue(t))}get g(){return pt(this,ct)}set g(t){wt(this,ct,this.validateValue(t))}get b(){return pt(this,dt)}set b(t){wt(this,dt,this.validateValue(t))}get a(){return pt(this,ut)}set a(t){wt(this,ut,this.validateValue(t))}fromRGB(t,e,i,s){return wt(this,lt,this.validateValue(t/255)),wt(this,ct,this.validateValue(e/255)),wt(this,dt,this.validateValue(i/255)),void 0!==s&&this.multiply(this.validateValue(s)),this}multiply(t){wt(this,lt,this.validateValue(pt(this,lt)*t)),wt(this,ct,this.validateValue(pt(this,ct)*t)),wt(this,dt,this.validateValue(pt(this,dt)*t)),wt(this,ut,this.validateValue(pt(this,ut)*t))}toArray(){return[pt(this,lt),pt(this,ct),pt(this,dt),pt(this,ut)]}toString(){const t=Math.floor(255*pt(this,lt)),e=Math.floor(255*pt(this,ct)),i=Math.floor(255*pt(this,dt));let s=t.toString(16);1===s.length&&(s="0"+s);let r=e.toString(16);1===r.length&&(r="0"+r);let n=i.toString(16);return 1===n.length&&(n="0"+n),`(${t} ${e} ${i}) ${pt(this,ut).toFixed(4)}, 0x${s}${r}${n}`}validateValue(t){return t<1/255?0:t>1?1:Math.floor(t/(1/255))*(1/255)}}lt=new WeakMap,ct=new WeakMap,dt=new WeakMap,ut=new WeakMap;const gt={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};Object.freeze(gt);class yt{constructor(t,e,i){this.program=J(t.gl,e,i),Object.defineProperty(this,"program",{writable:!1})}}var mt,vt,Et,bt,Tt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},xt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Mt{constructor(t){mt.set(this,void 0),vt.set(this,void 0),Et.set(this,void 0),bt.set(this,void 0),this.gl=t,this.extensions={ANGLE_instanced_arrays:this.gl.getExtension("ANGLE_instanced_arrays")},Tt(this,mt,null),Tt(this,vt,-1),Tt(this,Et,-1),Tt(this,bt,-1),function(t){t.enable(t.BLEND),t.blendFunc(t.ONE,t.ONE_MINUS_SRC_ALPHA),t.clearDepth(1),t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL)}(this.gl),Object.defineProperty(this,"gl",{writable:!1}),Object.defineProperty(this,"extensions",{writable:!1})}get drawWidth(){return xt(this,vt)}get drawHeight(){return xt(this,Et)}get scale(){return xt(this,bt)}get isLandscape(){return xt(this,vt)>=xt(this,Et)}setCanvasDimensions(t,e){return this.gl.canvas.width=t,this.gl.canvas.height=e,this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),xt(this,vt)<0&&this.setResolution(t,e),this}setResolution(t,e){return Tt(this,vt,Math.max(0,t)),Tt(this,Et,Math.max(0,e)),this.isLandscape?(Tt(this,bt,this.gl.canvas.height/xt(this,Et)),xt(this,vt)*xt(this,bt)>this.gl.canvas.width&&Tt(this,bt,this.gl.canvas.width/xt(this,vt))):(Tt(this,bt,this.gl.canvas.width/xt(this,vt)),xt(this,Et)*xt(this,bt)>this.gl.canvas.height&&Tt(this,bt,this.gl.canvas.width/xt(this,vt))),this}clear(t){var e,i,s,r,n;e=this.gl,i=t.r,s=t.g,r=t.b,n=t.a,e.clearColor(i,s,r,n),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}begin(t){return Tt(this,mt,t.program),this.gl.useProgram(xt(this,mt)),this}setVertexBuffer(...t){if(null===xt(this,mt))throw new Error("'begin(effect)' must be called before setting a VertexBuffer.");for(let e=0;e<t.length;e++){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,t[e].buffer);for(let i of t[e].attributeSchema.elements){const s=this.gl.getAttribLocation(xt(this,mt),i.name);if(s<0)throw new Error(`The current program does not have a(n) '${i.name}' attribute.`);this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,i.size,i.type,!1,i.stride,i.offset),this.extensions.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(s,t[e].instanceFrequency)}}return this}setIndexBuffer(t){return this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer),this}setUniform(t,e){if(null===xt(this,mt))throw new Error("'begin(effect)' must be called before setting a uniform.");const i=this.gl.getUniformLocation(xt(this,mt),t);return this.gl.uniformMatrix4fv(i,!1,e),this}setUniform2(t){if(null===xt(this,mt))throw new Error("'begin(effect)' must be called before setting a NULL.");const e=this.gl.getUniformLocation(xt(this,mt),t);return this.gl.uniform1i(e,0),this}setTexture(t){return this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this}drawArrays(t,e,i){return this.gl.drawArrays(t,e,i),this}drawElements(t,e,i){return this.gl.drawElements(t,3*e,this.gl.UNSIGNED_SHORT,i),this}drawInstancedElements(t,e,i,s){return this.extensions.ANGLE_instanced_arrays.drawElementsInstancedANGLE(t,3*e,this.gl.UNSIGNED_SHORT,i,s),this}disableVertexBuffer(...t){if(null===xt(this,mt))throw new Error("'begin(effect)' must be called before deleting a Buffer.");for(let e=0;e<t.length;e++)for(let i of t[e].attributeSchema.elements){const t=this.gl.getAttribLocation(xt(this,mt),i.name);if(t<0)throw new Error(`The current program does not have a(n) '${i.name}' attribute.`);this.gl.disableVertexAttribArray(t)}return this}end(){Tt(this,mt,null)}}mt=new WeakMap,vt=new WeakMap,Et=new WeakMap,bt=new WeakMap;class _t extends ot{constructor(t,e){var i,s;super(t,e,rt.INDEX),this.data=new Int16Array(this.length),this.buffer=(i=t.gl,s=this.data.byteLength,tt(i,i.ELEMENT_ARRAY_BUFFER,s,i.STATIC_DRAW))}}class kt{constructor(t,e){this.vertices=t,this.indices=e,this.totalVertices=t.length/3,this.totalIndices=e.length,Object.defineProperty(this,"vertices",{writable:!1}),Object.defineProperty(this,"indices",{writable:!1}),Object.defineProperty(this,"totalVertices",{writable:!1}),Object.defineProperty(this,"totalIndices",{writable:!1})}}var At,St,Wt,Pt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Rt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Ot{constructor(t,e){At.set(this,void 0),St.set(this,void 0),Wt.set(this,void 0),Pt(this,At,0),Pt(this,St,0),Pt(this,Wt,null),void 0!==t&&Pt(this,At,t),void 0!==e&&Pt(this,St,e)}get width(){return Rt(this,At)}get height(){return Rt(this,St)}get data(){return Rt(this,Wt)}setPixels(t,e){Pt(this,Wt,function(t,e,i,s){const r=t.createTexture();if(null===r)throw new Error("Something went wrong; could not create WebGLTexture.");return t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,i,0,t.RGBA,t.UNSIGNED_BYTE,s),st(e)&&st(i)?t.generateMipmap(t.TEXTURE_2D):(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST)),r}(t.gl,Rt(this,At),this.height,e))}static async fromURL(t,e){const i=await async function(t){return new Promise((e,i)=>{try{const i=new Image;i.onload=()=>{e(i)},i.src=t}catch(t){i(t)}})}(e),s=function(t,e){const i=t.createTexture();if(null===i)throw new Error("Something went wrong; could not create WebGLTexture.");return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),st(e.width)&&st(e.height)?t.generateMipmap(t.TEXTURE_2D):(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST)),i}(t.gl,i),r=new Ot(i.width,i.height);return Pt(r,Wt,s),r}}At=new WeakMap,St=new WeakMap,Wt=new WeakMap;class Lt extends ot{constructor(t,e,i,s,r){var n,a,h;super(t,i,rt.VERTEX),this.attributeSchema=e,this.vertexUsage=s,this.instanceFrequency=r||0,this.data=new Float32Array(this.length),this.buffer=(n=t.gl,a=this.data.byteLength,h=this.vertexUsage,tt(n,n.ARRAY_BUFFER,a,h)),Object.defineProperty(this,"attributeSchema",{writable:!1}),Object.defineProperty(this,"vertexUsage",{writable:!1}),Object.defineProperty(this,"instanceFrequency",{writable:!1})}}const It={STREAM:35040,STATIC:35044,DYNAMIC:35048};Object.freeze(It);class zt{constructor(t){this.gamepad=t,Object.defineProperty(this,"gamepad",{writable:!1})}}const Nt=new Map,Bt=new Map;function Dt(t,e){const i=t.toLocaleLowerCase().split(",");for(let t=0;t<i.length;t++){const s=i[t].trim();if(Bt.has(s)){const t=Bt.get(s);if(e.gamepad.buttons[t].pressed&&e.gamepad.buttons[t].value>0)return!0}}return!1}Bt.set("a",0),Bt.set("b",1),Bt.set("x",2),Bt.set("y",3),Bt.set("leftbumper",4),Bt.set("rightbumper",5),Bt.set("lefttrigger",6),Bt.set("righttrigger",7),Bt.set("back",8),Bt.set("start",9),Bt.set("leftstick",10),Bt.set("rightstick",11),Bt.set("dpadup",12),Bt.set("dpaddown",13),Bt.set("dpadleft",14),Bt.set("dpadright",15),window.addEventListener("gamepadconnected",t=>{Nt.set(t.gamepad.index,t.gamepad)}),window.addEventListener("gamepaddisconnected",t=>{Nt.delete(t.gamepad.index)});class Gt{constructor(t,e){this.event=t,this.keysPressed=new Set(e),Object.defineProperty(this,"event",{writable:!1}),Object.defineProperty(this,"keysPressed",{writable:!1})}}const Ut=new Set;let Ct=null;function jt(t,e){const i=t.toLocaleLowerCase().split(",");for(let t=0;t<i.length;t++)if(e.keysPressed.has(i[t].trim()))return!0;return!1}window.addEventListener("keydown",t=>{Ct=t,t.repeat||Ut.add(t.key.toLocaleLowerCase())}),window.addEventListener("keyup",t=>{Ct=t,Ut.delete(t.key.toLocaleLowerCase())}),window.addEventListener("blur",()=>{Ct=null,Ut.clear()});var Ft,Vt,Xt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},$t=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class qt{constructor(){Ft.set(this,void 0),Vt.set(this,void 0),Xt(this,Ft,null),Xt(this,Vt,null)}pressed(t){return null!==$t(this,Ft)&&null!==$t(this,Vt)&&(!jt(t,$t(this,Ft))&&jt(t,$t(this,Vt)))}pressing(t){return null!==$t(this,Vt)&&jt(t,$t(this,Vt))}update(){Xt(this,Ft,$t(this,Vt)),Xt(this,Vt,null===Ct?null:new Gt(Ct,Ut))}}Ft=new WeakMap,Vt=new WeakMap;var Ht,Yt,Kt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Zt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Qt{constructor(t){Ht.set(this,void 0),Yt.set(this,void 0),this.playerIndex=t,Kt(this,Ht,null),Kt(this,Yt,null),Object.defineProperty(this,"playerIndex",{writable:!1})}get connected(){return null!==Zt(this,Yt)}get description(){return null===Zt(this,Yt)?"":Zt(this,Yt).gamepad.id}get leftStickAxes(){return null===Zt(this,Yt)?{x:0,y:0}:{x:Zt(this,Yt).gamepad.axes[0],y:-Zt(this,Yt).gamepad.axes[1]}}get rightStickAxes(){return null===Zt(this,Yt)?{x:0,y:0}:{x:Zt(this,Yt).gamepad.axes[2],y:-Zt(this,Yt).gamepad.axes[3]}}get buttons(){return null===Zt(this,Yt)?[]:Zt(this,Yt).gamepad.axes}pressed(t){return null!==Zt(this,Ht)&&null!==Zt(this,Yt)&&(!Dt(t,Zt(this,Ht))&&Dt(t,Zt(this,Yt)))}pressing(t){return null!==Zt(this,Yt)&&Dt(t,Zt(this,Yt))}update(){var t;Kt(this,Ht,Zt(this,Yt)),Kt(this,Yt,(t=this.playerIndex,Nt.has(t)?new zt(Nt.get(t)):null))}}Ht=new WeakMap,Yt=new WeakMap;class Jt{constructor(t){this.event=t,Object.defineProperty(this,"event",{writable:!1})}}let te=null;function ee(t,e){const i=t.toLocaleLowerCase().split(","),s=new Set(i);let r=0;for(let t of s)switch(t.trim()){case"leftclick":r+=1;break;case"rightclick":r+=2;break;case"middleclick":r+=4}return 0!=(e.event.buttons&r)}window.addEventListener("pointermove",t=>{te=t}),window.addEventListener("pointerdown",t=>{te=t}),window.addEventListener("pointerup",t=>{te=t}),window.addEventListener("blur",()=>{te=null});var ie,se,re,ne,ae,he=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},oe=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class le{constructor(){ie.set(this,void 0),se.set(this,void 0),re.set(this,void 0),ne.set(this,void 0),ae.set(this,void 0),he(this,ie,null),he(this,se,null),he(this,re,null),he(this,ne,0),he(this,ae,0)}get x(){return oe(this,ne)}get y(){return oe(this,ae)}attachElement(t){he(this,ie,t)}pressed(t){return null!==oe(this,se)&&null!==oe(this,re)&&(!ee(t,oe(this,se))&&ee(t,oe(this,re)))}pressing(t){return null!==oe(this,re)&&ee(t,oe(this,re))}update(){he(this,se,oe(this,re)),he(this,re,null===te?null:new Jt(te)),null!==oe(this,ie)&&null!==oe(this,re)&&(he(this,ne,oe(this,re).event.clientX-oe(this,ie).offsetLeft),he(this,ae,oe(this,re).event.clientY-oe(this,ie).offsetTop))}}ie=new WeakMap,se=new WeakMap,re=new WeakMap,ne=new WeakMap,ae=new WeakMap;var ce,de,ue,we,pe,fe=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ge=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class ye{constructor(t,e){ce.set(this,void 0),de.set(this,void 0),ue.set(this,void 0),we.set(this,void 0),pe.set(this,void 0),this.playerIndex=e,fe(this,ce,new qt),fe(this,de,new le),fe(this,ue,new Qt(e)),fe(this,we,null),fe(this,pe,"keyboard"),ge(this,de).attachElement(t),Object.defineProperty(this,"playerIndex",{writable:!1})}get lastInputType(){return ge(this,pe)}get pointerPosition(){return{x:ge(this,de).x,y:ge(this,de).y}}loadProfile(t){return fe(this,we,t),this}pressed(t){if(null===ge(this,we))throw new TypeError("An input profile has not been loaded yet.");const e=ge(this,we).getMapping(t);return void 0!==e&&(0===this.playerIndex&&(ge(this,ce).pressed(e.keys)||ge(this,de).pressed(e.mouseButtons))?(fe(this,pe,"keyboard"),!0):!(!ge(this,ue).connected||!ge(this,ue).pressed(e.gamepadButtons))&&(fe(this,pe,"gamepad"),!0))}pressing(t){if(null===ge(this,we))throw new TypeError("An input profile has not been loaded yet.");const e=ge(this,we).getMapping(t);return void 0!==e&&(0===this.playerIndex&&(ge(this,ce).pressing(e.keys)||ge(this,de).pressing(e.mouseButtons))?(fe(this,pe,"keyboard"),!0):!(!ge(this,ue).connected||!ge(this,ue).pressing(e.gamepadButtons))&&(fe(this,pe,"gamepad"),!0))}update(){ge(this,ce).update(),ge(this,de).update(),ge(this,ue).update()}}ce=new WeakMap,de=new WeakMap,ue=new WeakMap,we=new WeakMap,pe=new WeakMap;var me,ve,Ee,be=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Te=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class xe{constructor(t,e,i,s){me.set(this,void 0),ve.set(this,void 0),Ee.set(this,void 0),this.name=t,be(this,me,""),be(this,ve,""),be(this,Ee,""),void 0!==e&&be(this,me,e),void 0!==i&&be(this,ve,i),void 0!==s&&be(this,Ee,s),Object.defineProperty(this,"name",{writable:!1})}get keys(){return Te(this,me)}get gamepadButtons(){return Te(this,ve)}get mouseButtons(){return Te(this,Ee)}remapKeys(t){be(this,me,t)}remapGamepadButtons(t){be(this,ve,t)}remapMouseButtons(t){be(this,Ee,t)}}me=new WeakMap,ve=new WeakMap,Ee=new WeakMap;var Me,_e=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ke=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function Ae(t){return t.toLocaleLowerCase()}class Se{constructor(t){Me.set(this,void 0),this.name=t,_e(this,Me,new Map)}createMapping(t,e,i,s){const r=Ae(t);if(ke(this,Me).has(r))throw new TypeError("An InputMapping with that name already exists; try a different name.");const n=new xe(r,e,i,s);return ke(this,Me).set(n.name,n),this}getMapping(t){const e=Ae(t);if(!ke(this,Me).has(e))throw new TypeError("An InputMapping with that name has not been registered.");return ke(this,Me).get(e)}remapKeys(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapKeys(e)}remapGamepadButtons(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapGamepadButtons(e)}remapMouseButtons(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapMouseButtons(e)}removeMapping(t){const e=Ae(t);if(!ke(this,Me).has(e))throw new TypeError("An InputMapping with that name has not been registered.");return ke(this,Me).delete(e),this}}Me=new WeakMap;const We=function(){const t=!!window.opr&&!!opr.addons||!!window.opera||navigator.userAgent.indexOf(" OPR/")>=0,e="undefined"!=typeof InstallTrigger,i=/constructor/i.test(window.HTMLElement)||"[object SafariRemoteNotification]"===(!window.safari||"undefined"!=typeof safari&&safari.pushNotification).toString(),s=/*@cc_on!@*/!!document.documentMode,r=!s&&!!window.StyleMedia,n=!(!window.chrome||!window.chrome.webstore&&!window.chrome.runtime&&!window.chrome.csi),a=n&&-1!=navigator.userAgent.indexOf("Edg"),h=(n||t)&&!!window.CSS;let o="";return o=t?"opera":o,o=e?"firefox":o,o=i?"safari":o,o=s?"ie":o,o=r?"edge":o,o=n?"chrome":o,o=a?"edgechromium":o,{browserName:o,isBlink:h}}().isBlink;var Pe,Re=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Oe=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function Le(t){return t.toLocaleLowerCase()}class Ie{constructor(){Pe.set(this,void 0),Re(this,Pe,new Map)}get length(){return Oe(this,Pe).entries.length}get entries(){return Oe(this,Pe).entries}register(t,e){const i=Le(t);if(Oe(this,Pe).has(i))throw new TypeError("An entry with that name already exists; try a different name.");Oe(this,Pe).set(i,e)}get(t){const e=Le(t);if(!Oe(this,Pe).has(e))throw new TypeError("An entry with that name has not been registered.");return Oe(this,Pe).get(e)}remove(t){const e=Le(t);if(!Oe(this,Pe).has(e))throw new TypeError("An entry with that name has not been registered.");Oe(this,Pe).delete(e)}}Pe=new WeakMap;var ze,Ne,Be,De,Ge=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Ue=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Ce{constructor(t){if(ze.set(this,void 0),Ne.set(this,void 0),Be.set(this,void 0),De.set(this,void 0),t<0)throw new TypeError("The range must be greater than or equal to zero.");Ge(this,Be,t),Ge(this,De,0),Ge(this,Ne,new Array(Ue(this,Be)).fill(0)),Ge(this,ze,new Array(Ue(this,Be)).fill(0))}get size(){return Ue(this,De)}get values(){return function*(t){for(let e=0;e<t.length;e++)yield t[e]}(Ue(this,ze).slice(0,Ue(this,De)))}has(t){if(t<0)throw new TypeError("The 'value' parameter must be a positive number.");return t<Ue(this,Be)&&Ue(this,Ne)[t]<Ue(this,De)&&Ue(this,ze)[Ue(this,Ne)[t]]===t}add(t){if(t>=Ue(this,Be))throw new TypeError("The 'value' parameter cannot be greater than or equal to the SparseSet's range.");return!this.has(t)&&(Ue(this,ze)[Ue(this,De)]=t,Ue(this,Ne)[t]=Ue(this,De),Ge(this,De,+Ue(this,De)+1),!0)}delete(t){if(!this.has(t))return!1;Ge(this,De,+Ue(this,De)-1);for(let e=Ue(this,ze).indexOf(t);e<Ue(this,De);e++)Ue(this,ze)[e]=Ue(this,ze)[e+1],Ue(this,Ne)[Ue(this,ze)[e+1]]=e;return!0}clear(){Ge(this,De,0)}*[(ze=new WeakMap,Ne=new WeakMap,Be=new WeakMap,De=new WeakMap,Symbol.iterator)](){for(let t=0;t<Ue(this,De);t++)yield Ue(this,ze)[t]}}var je,Fe,Ve,Xe=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},$e=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class qe{constructor(){je.set(this,void 0),Fe.set(this,void 0),Ve.set(this,void 0),this.scenes=new Ie,Xe(this,je,!1),Xe(this,Fe,null),Xe(this,Ve,null),Object.defineProperty(this,"scenes",{writable:!1}),Object.defineProperty(this,"graphics",{writable:!1})}register(...t){for(let e=0;e<t.length;e++)this.scenes.register(t[e].name,t[e]);return this}queue(t){const e=this.scenes.get(t);if(void 0===e)throw new Error("Something went wrong!");Xe(this,Ve,e),Xe(this,je,!0)}update(t){var e;this.updateTransitions(),null===(e=$e(this,Fe))||void 0===e||e.update(t)}draw(t,e){var i;null===(i=$e(this,Fe))||void 0===i||i.draw(t,e)}updateTransitions(){var t,e;$e(this,je)&&(null===(t=$e(this,Fe))||void 0===t||t.onExit(),null===(e=$e(this,Ve))||void 0===e||e.onEnter(),Xe(this,Fe,$e(this,Ve)),Xe(this,je,!1))}}je=new WeakMap,Fe=new WeakMap,Ve=new WeakMap;const He=new kt([0,0,0,1,0,0,1,-1,0,0,-1,0],[0,3,1,1,3,2]),Ye=function(){const t=Math.sqrt(3)/2;return new kt([1-t,0,0,1,-.5,0,1-t,-1,0],[0,2,1])}(),Ke=function(t){if(t<=2)throw new TypeError("A polygon must have at least 3 vertices.");const e=2*Math.PI,i=[],s=[],r=3*(t-2),n=e/t;for(let s=e;s>=0&&(i.push(.5+.5*Math.cos(s)),i.push(.5*Math.sin(s)-.5),i.push(0),!(i.length>=3*t));s-=n);let a=1;for(let t=0;t<r;t+=3)s.push(0),s.push(a+1),s.push(a),a++;return new kt(i,s)}(90);const Ze=new Q([new Y("a_vertexPosition",3,K.FLOAT)]);class Qe{constructor(t,e){this.vertexBuffer=new Lt(t,Ze,e.vertices.length,It.STATIC),this.indexBuffer=new _t(t,e.indices.length),this.totalVertices=e.totalVertices,this.totalTriangles=e.totalIndices/3,this.vertexBuffer.setData(e.vertices),this.indexBuffer.setData(e.indices),Object.defineProperty(this,"vertexBuffer",{writable:!1}),Object.defineProperty(this,"indexBuffer",{writable:!1}),Object.defineProperty(this,"totalVertices",{writable:!1}),Object.defineProperty(this,"totalTriangles",{writable:!1})}}var Je,ti,ei=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ii=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class si{constructor(t){Je.set(this,void 0),ti.set(this,void 0),ei(this,Je,t),ei(this,ti,new Ie),this.createDefaults()}registerGeometry(t,e){return ii(this,ti).register(t,e),this}getGeometry(t){return ii(this,ti).get(t)}removeGeometry(t){return ii(this,ti).remove(t),this}createDefaults(){this.registerGeometry("Susurrus_Circle",new Qe(ii(this,Je),Ke)),this.registerGeometry("Susurrus_Square",new Qe(ii(this,Je),He)),this.registerGeometry("Susurrus_Triangle",new Qe(ii(this,Je),Ye))}}Je=new WeakMap,ti=new WeakMap;var ri,ni,ai,hi,oi,li,ci,di,ui,wi,pi,fi,gi,yi,mi,vi,Ei=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},bi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};const Ti=new Q([new Y("a_translation",3,K.FLOAT),new Y("a_scale",3,K.FLOAT),new Y("a_rotationOffset",3,K.FLOAT),new Y("a_rotation",1,K.FLOAT),new Y("a_color",4,K.FLOAT)]);class xi{constructor(t,e,i,s,r){ri.set(this,void 0),ni.set(this,void 0),ai.set(this,void 0),hi.set(this,void 0),oi.set(this,void 0),li.set(this,void 0),ci.set(this,void 0),di.set(this,void 0),ui.set(this,void 0),wi.set(this,void 0),pi.set(this,void 0),fi.set(this,void 0),gi.set(this,void 0),yi.set(this,void 0),mi.set(this,void 0),vi.set(this,void 0),Ei(this,ri,t),Ei(this,ai,null),Ei(this,ni,null),Ei(this,oi,e),Ei(this,li,i),Ei(this,ci,0),Ei(this,di,s),Ei(this,ui,r),Ei(this,wi,new m(0,0,0)),Ei(this,pi,new m(1,1,1)),Ei(this,fi,new m(0,0,0)),Ei(this,gi,0),Ei(this,yi,new ft(16777215)),Ei(this,mi,!1),Ei(this,vi,!1),Ei(this,hi,null)}get x(){return bi(this,oi)}set x(t){t!==bi(this,oi)&&(Ei(this,oi,t),Ei(this,vi,!0))}get y(){return bi(this,li)}set y(t){t!==bi(this,li)&&(Ei(this,li,t),Ei(this,vi,!0))}get z(){return bi(this,ci)}set z(t){t!==bi(this,ci)&&(Ei(this,ci,t),Ei(this,vi,!0))}get width(){return bi(this,di)}set width(t){t!==bi(this,di)&&(Ei(this,di,t),Ei(this,vi,!0))}get height(){return bi(this,ui)}set height(t){t!==bi(this,ui)&&(Ei(this,ui,t),Ei(this,vi,!0))}get translation(){return bi(this,wi)}set translation(t){t!==bi(this,wi)&&(Ei(this,wi,t),Ei(this,vi,!0))}get scale(){return bi(this,pi)}set scale(t){t!==bi(this,pi)&&(Ei(this,pi,t),Ei(this,vi,!0))}get rotationOffset(){return bi(this,fi)}set rotationOffset(t){t!==bi(this,fi)&&(Ei(this,fi,t),Ei(this,vi,!0))}get rotation(){return bi(this,gi)}set rotation(t){t!==bi(this,gi)&&(Ei(this,gi,t),Ei(this,vi,!0))}get color(){return bi(this,yi)}set color(t){t!==bi(this,yi)&&(Ei(this,yi,t),Ei(this,vi,!0))}get position(){return new m(bi(this,oi),bi(this,li),bi(this,ci))}get aabb(){return new h(bi(this,oi),bi(this,li),bi(this,di),bi(this,ui))}setPosition(t,e,i){return Ei(this,oi,t),Ei(this,li,e),Ei(this,ci,i),Ei(this,vi,!0),this}attachMesh(t){return Ei(this,ri,t),Ei(this,mi,!0),this}attachGeometry(t){return Ei(this,ai,t),this}attachEffect(t){return Ei(this,hi,t),this}createGeometry(t){return Ei(this,ai,new Qe(t,bi(this,ri))),this}createModelBuffer(t){Ei(this,mi,!1);let e=Ti.size;return We&&(e*=bi(this,ri).totalVertices),Ei(this,ni,new Lt(t,Ti,e,It.DYNAMIC,1)),this.updateModelBuffer(),this}calculateTransform(){const t=M.createScale(this.width*this.scale.x,this.height*this.scale.y,this.scale.z),e=M.createTranslation(-this.rotationOffset.x,-this.rotationOffset.y,0),i=M.createRotationZ(this.rotation),s=M.createTranslation(this.x+this.translation.x+this.rotationOffset.x,this.y+this.translation.y+this.rotationOffset.y,this.translation.z),r=M.multiply;return r(r(r(t,e),i),s)}applyChanges(){if(null===bi(this,ni))throw new TypeError("A model has not been created; cannot apply changes.");Ei(this,vi,!1),this.updateModelBuffer()}draw(t,e){if(null!==bi(this,ai)&&null!==bi(this,ni)&&null!==bi(this,hi)){if(bi(this,mi))throw new TypeError("The polygon's mesh was modified, but a new model was not created. Make sure to call createModel(graphics).");if(bi(this,vi))throw new TypeError("The polygon's transform was modified, but applyChanges() was never called.");t.begin(bi(this,hi)).setVertexBuffer(bi(this,ai).vertexBuffer,bi(this,ni)).setIndexBuffer(bi(this,ai).indexBuffer).setUniform("worldViewProjection",e.wvp.data).drawElements(gt.TRIANGLES,bi(this,ai).totalTriangles,0).end()}}updateModelBuffer(){if(null===bi(this,ni))return;let t=[];t=t.concat(new m(bi(this,oi)+this.translation.x,bi(this,li)+this.translation.y,bi(this,ci)+this.translation.z).toArray()),t=t.concat(new m(bi(this,di)*bi(this,pi).x,bi(this,ui)*bi(this,pi).y,bi(this,pi).z).toArray()),t=t.concat(bi(this,fi).toArray()),t=t.concat(bi(this,gi)),t=t.concat(bi(this,yi).toArray()),bi(this,ni).setData(t)}}ri=new WeakMap,ni=new WeakMap,ai=new WeakMap,hi=new WeakMap,oi=new WeakMap,li=new WeakMap,ci=new WeakMap,di=new WeakMap,ui=new WeakMap,wi=new WeakMap,pi=new WeakMap,fi=new WeakMap,gi=new WeakMap,yi=new WeakMap,mi=new WeakMap,vi=new WeakMap;class Mi extends xi{constructor(t,e,i,s){super(He,t,e,i,s)}}class _i extends xi{constructor(t,e,i){super(Ke,t,e,2*i,2*i),this.radius=i}}const ki={VERTEX:"\n\t\tuniform mat4 worldViewProjection;\n\n\t\tattribute vec3 a_vertexPosition;\n\t\tattribute vec3 a_translation;\n\t\tattribute vec3 a_scale;\n\t\tattribute vec3 a_rotationOffset;\n\t\tattribute float a_rotation;\n\t\tattribute vec4 a_color;\n\n\t\tvarying lowp vec4 v_color;\n\n\t\tmat4 createTranslation(vec3 translation) {\n\t\t\treturn mat4(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\ttranslation.x, translation.y, translation.z, 1\n\t\t\t);\n\t\t}\n\n\t\tmat4 createScale(vec3 scale) {\n\t\t\treturn mat4(\n\t\t\t\tscale.x, 0, 0, 0,\n\t\t\t\t0, scale.y, 0, 0,\n\t\t\t\t0, 0, scale.z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tmat4 createRotationZ(float theta) {\n\t\t\treturn mat4(\n\t\t\t\tcos(theta), -sin(theta), 0, 0,\n\t\t\t\tsin(theta), cos(theta), 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tmat4 model = createTranslation(a_translation - a_rotationOffset) * createRotationZ(a_rotation) * createTranslation(a_rotationOffset) * createScale(a_scale);\n\t\t\tgl_Position = worldViewProjection * model * vec4(a_vertexPosition, 1);\n\n\t\t\tv_color = a_color;\n\t\t}\n\t",FRAGMENT:"\n\t\tvarying lowp vec4 v_color;\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = v_color;\n\t\t}\n\t"};Object.freeze(ki);class Ai extends yt{constructor(t){super(t,ki.VERTEX,ki.FRAGMENT)}}var Si,Wi,Pi,Ri=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Oi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Li{constructor(t){Si.set(this,void 0),Wi.set(this,void 0),Pi.set(this,void 0),Ri(this,Si,t),Ri(this,Wi,null),Ri(this,Pi,null)}attachGraphics(t){Ri(this,Wi,t),Ri(this,Pi,new Ai(Oi(this,Wi)))}createCircle(t,e,i){if(null===Oi(this,Wi))throw new TypeError("A GraphicsManager has not been attached; cannot create geometry. Make sure to call 'attachGraphics(graphics)' before using a Factory.");if(null===Oi(this,Pi))throw new Error("Something unexpected happen! Could not create shared PolygonEffect.");if(null===Oi(this,Si).geometryManager)throw new Error("Something unexpected happen! The Theater's GeometryManager was not initialized.");const s=Oi(this,Si).geometryManager.getGeometry("Susurrus_Circle");if(void 0===s)throw new Error("Could not find geometry.");return new _i(t,e,i).attachEffect(Oi(this,Pi)).attachGeometry(s).createModelBuffer(Oi(this,Wi))}createQuad(t,e,i,s){if(null===Oi(this,Wi))throw new TypeError("A GraphicsManager has not been attached; cannot create geometry. Make sure to call 'attachGraphics(graphics)' before using a Factory.");if(null===Oi(this,Pi))throw new Error("Something unexpected happen! Could not create shared PolygonEffect.");if(null===Oi(this,Si).geometryManager)throw new Error("Something unexpected happen! The Theater's GeometryManager was not initialized.");const r=Oi(this,Si).geometryManager.getGeometry("Susurrus_Square");if(void 0===r)throw new Error("Could not find geometry.");return new Mi(t,e,i,s).attachEffect(Oi(this,Pi)).attachGeometry(r).createModelBuffer(Oi(this,Wi))}}Si=new WeakMap,Wi=new WeakMap,Pi=new WeakMap;var Ii,zi,Ni,Bi,Di,Gi,Ui,Ci,ji=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Fi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Vi{constructor(){Ii.set(this,void 0),zi.set(this,void 0),Ni.set(this,void 0),Bi.set(this,void 0),Di.set(this,void 0),Gi.set(this,void 0),Ui.set(this,void 0),Ci.set(this,void 0),ji(this,Ii,null),ji(this,zi,null),ji(this,Ni,null),ji(this,Bi,null),this.smartKeyboard=new qt,this.smartPointer=new le,this.sceneManager=new qe,this.factory=new Li(this),this.loop=!0,ji(this,Di,!1),ji(this,Gi,!1),ji(this,Ui,0),ji(this,Ci,[]),window.addEventListener("mousedown",t=>{null!==Fi(this,zi)&&ji(this,Gi,t.target===Fi(this,zi))}),Object.defineProperty(this,"smartKeyboard",{writable:!1}),Object.defineProperty(this,"smartPointer",{writable:!1}),Object.defineProperty(this,"sceneManager",{writable:!1}),Object.defineProperty(this,"factory",{writable:!1})}get parent(){return Fi(this,Ii)}get canvas(){return Fi(this,zi)}get graphics(){return Fi(this,Ni)}get geometryManager(){return Fi(this,Bi)}get inFocus(){return Fi(this,Gi)}get totalElapsedTime(){return Fi(this,Ui)}get args(){return Fi(this,Ci)}run(t){if(!Fi(this,Di)){if(void 0!==t){const e=t.trim().split(" ");ji(this,Ci,e)}this.initialize(),ji(this,Di,!0)}this.main(0)}setParent(t){const e=document.getElementById(t);if(null===e)throw new TypeError(`Could not find an element with an id of '${t}'.`);return ji(this,Ii,e),this}createCanvas(t,e,i){if(null===Fi(this,Ii))throw new Error("A parent element does not exist; a canvas cannot be created. Make sure to call that 'setParent(id)' was called.");ji(this,zi,document.createElement("canvas")),Fi(this,zi).id=t,Fi(this,zi).width=e,Fi(this,zi).height=i,Fi(this,Ii).appendChild(Fi(this,zi)),ji(this,Ni,new Mt(function(t){const e=t.getContext("webgl");if(null===e)throw new Error("WebGL is not supported on this device.");return e}(Fi(this,zi)))),ji(this,Bi,new si(Fi(this,Ni))),this.factory.attachGraphics(Fi(this,Ni)),this.smartPointer.attachElement(Fi(this,zi))}initialize(){}update(t){this.sceneManager.update(t)}draw(t){if(null===Fi(this,Ni))throw new TypeError("The GraphicsManager has not been instantiated; cannot draw anything. Make sure to call appendCanvas() before rendering anything.");this.sceneManager.draw(Fi(this,Ni),t)}managedUpdate(t){this.smartKeyboard.update(),this.smartPointer.update()}main(t){let e=(t-Fi(this,Ui))/1e3;Number.isNaN(e)&&(e=0),ji(this,Ui,t),this.managedUpdate(e),this.update(e),null!==this.graphics&&this.draw(e),this.loop&&window.requestAnimationFrame(t=>{this.main(t)})}}Ii=new WeakMap,zi=new WeakMap,Ni=new WeakMap,Bi=new WeakMap,Di=new WeakMap,Gi=new WeakMap,Ui=new WeakMap,Ci=new WeakMap;const Xi={BLACK:new ft(0),WHITE:new ft(16777215),RED:new ft(16711680),GREEN:new ft(65280),BLUE:new ft(255)};Object.freeze(Xi);const $i={SKY_BLUE:new ft(2731519)};Object.freeze($i);var qi,Hi,Yi,Ki,Zi,Qi=Object.freeze({__proto__:null,BASIC:Xi,PICO8:$i}),Ji=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ts=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};const es=new Q([new Y("a_textureCoord",2,K.FLOAT)]),is=new Q([new Y("a_scale",3,K.FLOAT)]);class ss{constructor(t){qi.set(this,void 0),Hi.set(this,void 0),Yi.set(this,void 0),Ki.set(this,void 0),Zi.set(this,void 0),Ji(this,qi,t),Ji(this,Hi,null),Ji(this,Yi,null),Ji(this,Ki,null),Ji(this,Zi,null)}attachGeometry(t){return Ji(this,Hi,t),this}attachEffect(t){return Ji(this,Yi,t),this}createTextureBuffer(t){Ji(this,Ki,new Lt(t,es,8,It.STATIC)),ts(this,Ki).setData([0,0,1,0,1,1,0,1]);let e=is.size;return We&&(e*=6),Ji(this,Zi,new Lt(t,is,e,It.DYNAMIC,1)),ts(this,Zi).setData([ts(this,qi).width,ts(this,qi).height,1]),this}draw(t,e){null!==ts(this,qi).data&&null!==ts(this,Hi)&&null!==ts(this,Yi)&&null!==ts(this,Ki)&&null!==ts(this,Zi)&&t.begin(ts(this,Yi)).setVertexBuffer(ts(this,Hi).vertexBuffer,ts(this,Ki),ts(this,Zi)).setIndexBuffer(ts(this,Hi).indexBuffer).setUniform("worldViewProjection",e.wvp.data).setUniform2("sampler").setTexture(ts(this,qi).data).drawElements(gt.TRIANGLES,ts(this,Hi).totalTriangles,0).end()}}qi=new WeakMap,Hi=new WeakMap,Yi=new WeakMap,Ki=new WeakMap,Zi=new WeakMap;const rs={VERTEX:"\n\t\tuniform mat4 worldViewProjection;\n\n\t\tattribute vec3 a_vertexPosition;\n\t\tattribute vec2 a_textureCoord;\n\t\tattribute vec3 a_scale;\n\n\t\tvarying highp vec2 v_textureCoord;\n\n\t\tmat4 createScale(vec3 scale) {\n\t\t\treturn mat4(\n\t\t\t\t\tscale.x, 0, 0, 0,\n\t\t\t\t\t0, scale.y, 0, 0,\n\t\t\t\t\t0, 0, scale.z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tmat4 model = createScale(a_scale);\n\t\t\tgl_Position = worldViewProjection * model * vec4(a_vertexPosition, 1);\n\n\t\t\tv_textureCoord = a_textureCoord;\n\t\t}\n\t\t",FRAGMENT:"\n\t\tuniform sampler2D sampler;\n\n\t\tvarying highp vec2 v_textureCoord;\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = texture2D(sampler, v_textureCoord);\n\t\t}\n    "};Object.freeze(rs);class ns extends yt{constructor(t){super(t,rs.VERTEX,rs.FRAGMENT)}}class as{constructor(t){this.boundary=t}addRange(t){for(let e=0;e<t.length;e++)this.add(t[e])}}var hs,os,ls,cs,ds,us,ws=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ps=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function fs(t,e){let i=t.x,s=t.y;return i=Math.max(e.left,i),i=Math.min(e.right,i),s=Math.max(e.bottom,s),s=Math.min(e.top,s),{x:i,y:s}}class gs extends as{constructor(t,e){super(t),hs.set(this,void 0),os.set(this,void 0),ls.set(this,void 0),cs.set(this,void 0),ds.set(this,void 0),us.set(this,void 0),ws(this,hs,new h(i(this.boundary.x,this.boundary.left,this.boundary.right,0,this.boundary.width),i(this.boundary.y,this.boundary.bottom,this.boundary.top,0,this.boundary.height),this.boundary.width,this.boundary.height)),ws(this,os,Math.ceil(Math.log2(e))),ws(this,ls,1<<ps(this,os)),ws(this,cs,Math.ceil(this.boundary.width/2**ps(this,os))),ws(this,ds,Math.ceil(this.boundary.height/2**ps(this,os))),ws(this,us,new Array(ps(this,ds)*ps(this,cs)).fill(null));for(let t=0;t<ps(this,us).length;t++)ps(this,us)[t]=new Set}query(t){const e=[];if(this.boundary.completelyWithin(t)){for(let t=0;t<ps(this,us).length;t++)for(let i of ps(this,us)[t])e.push(i);return e}const i=new Set,s=this.getHashIDs(t);for(let t of s)for(let s of ps(this,us)[t])i.has(s)||(i.add(s),e.push(s));return e}add(t){if(!t.boundary.intersects(this.boundary))return!1;const e=this.getHashIDs(t.boundary);for(let i of e)ps(this,us)[i].add(t.identifier);return e.size>0}clear(){for(let t=0;t<ps(this,us).length;t++)ps(this,us)[t].clear()}getHashIDs(t){const e=new h(i(t.x,this.boundary.left,this.boundary.right,0,this.boundary.width),i(t.y,this.boundary.bottom,this.boundary.top,0,this.boundary.height),t.width,t.height),s=function(t,e){const i=fs({x:t.x,y:t.y},e),s=Math.min(t.width,e.right-i.x),r=Math.min(t.height,i.y-e.bottom);return new h(i.x,i.y,s,r)}(e,ps(this,hs)),r=[this.getHash(s.left,s.top),this.getHash(s.right,s.top),this.getHash(s.right,s.bottom),this.getHash(s.left,s.bottom)];if(s.width>ps(this,ls)||s.height>ps(this,ls)){const t=Math.ceil(s.height/ps(this,ls)),i=Math.ceil(s.width/ps(this,ls));for(let s=0;s<=t;s++)for(let t=0;t<=i;t++)r.push(this.getHash(e.x+t*ps(this,ls),e.y-s*ps(this,ls)))}return new Set(r.filter(t=>t>=0))}getHash(t,e){const i=fs({x:t,y:e},ps(this,hs)),s=i.x>>ps(this,os),r=i.y>>ps(this,os);return r<0||r>=ps(this,cs)||s<0||s>=ps(this,ds)?-1:ps(this,cs)*r+s}}hs=new WeakMap,os=new WeakMap,ls=new WeakMap,cs=new WeakMap,ds=new WeakMap,us=new WeakMap;var ys,ms,vs,Es,bs,Ts,xs,Ms,_s=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ks=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class As extends as{constructor(t,e){super(t),ys.set(this,void 0),ms.set(this,void 0),vs.set(this,void 0),Es.set(this,void 0),bs.set(this,void 0),Ts.set(this,void 0),xs.set(this,void 0),Ms.set(this,void 0),_s(this,ys,e),_s(this,ms,!1),_s(this,vs,0),_s(this,Es,new Array(ks(this,ys)).fill(null)),_s(this,bs,null),_s(this,Ts,null),_s(this,xs,null),_s(this,Ms,null)}query(t){const e=[];if(this.boundary.completelyWithin(t))for(let t=0;t<ks(this,Es).length;t++)null!==ks(this,Es)[t]&&e.push(ks(this,Es)[t].identifier);else for(let i=0;i<ks(this,Es).length;i++)null!==ks(this,Es)[i]&&t.intersects(ks(this,Es)[i].boundary)&&e.push(ks(this,Es)[i].identifier);return ks(this,ms)?(e.push(...ks(this,bs).query(t)),e.push(...ks(this,Ts).query(t)),e.push(...ks(this,xs).query(t)),e.push(...ks(this,Ms).query(t)),e):e}add(t){var e;return!!t.boundary.intersects(this.boundary)&&(ks(this,vs)<ks(this,ys)?(ks(this,Es)[(_s(this,vs,1+(e=+ks(this,vs))),e)]=t,!0):(ks(this,ms)||this.subdivide(),!!(ks(this,bs).insert(t)||ks(this,Ts).insert(t)||ks(this,xs).insert(t)||ks(this,Ms).insert(t))))}clear(){ks(this,ms)&&(ks(this,bs).clear(),ks(this,Ts).clear(),ks(this,xs).clear(),ks(this,Ms).clear(),_s(this,bs,null),_s(this,Ts,null),_s(this,xs,null),_s(this,Ms,null)),_s(this,ms,!1),_s(this,vs,0),ks(this,Es).fill(null)}subdivide(){const t=.5*this.boundary.width,e=.5*this.boundary.height;_s(this,bs,new As(new h(this.boundary.x,this.boundary.y,t,e),ks(this,ys))),_s(this,Ts,new As(new h(this.boundary.x+t,this.boundary.y,t,e),ks(this,ys))),_s(this,xs,new As(new h(this.boundary.x+t,this.boundary.y-e,t,e),ks(this,ys))),_s(this,Ms,new As(new h(this.boundary.x,this.boundary.y-e,t,e),ks(this,ys))),_s(this,ms,!0)}}ys=new WeakMap,ms=new WeakMap,vs=new WeakMap,Es=new WeakMap,bs=new WeakMap,Ts=new WeakMap,xs=new WeakMap,Ms=new WeakMap;export{Y as AttributeElement,Q as AttributeSchema,K as AttributeType,gs as Bin,q as Camera,p as CollisionHelper,ft as Color,gt as DrawMode,yt as Effect,Qe as GeometryData,_t as IndexBuffer,ye as InputHandler,Se as InputProfile,e as LineSegment,n as MathExt,y as Matrix,M as Matrix4,kt as Mesh,Qi as Palettes,as as Partitioner,xi as Polygon,Ai as PolygonEffect,Mi as Quad,As as Quadtree,W as Random,F as RandomHelper,h as Rectangle,H as Scene,Ce as SparseSet,ss as Sprite,ns as SpriteEffect,Ot as Texture2D,Vi as Theater,a as Vector2,m as Vector3,Lt as VertexBuffer,It as VertexUsage};
