!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Susurrus={})}(this,(function(t){"use strict";function e(t,e){return{x:t.x1+e*(t.x2-t.x1),y:t.y1+e*(t.y2-t.y1)}}class i{constructor(t,e,i,s){this.x1=t,this.y1=e,this.x2=i,this.y2=s}getIntersectionInformation(t){const i=t.x1,s=t.y1,r=t.x2,n=t.y2,a=(this.x1-this.x2)*(s-n)-(this.y1-this.y2)*(i-r);if(0===a)return null;let h=(this.x1-i)*(s-n)-(this.y1-s)*(i-r);const o=h/a;h=(this.x1-this.x2)*(this.y1-s)-(this.y1-this.y2)*(this.x1-i);const l=-h/a;return{t:o,u:l,intersected:0<=o&&o<=1&&0<=l&&l<=1,convergence:e(this,o)}}intersects(t){const e=this.getIntersectionInformation(t);return null!==e&&e.intersected}}function s(t,e,i,s,r){return s+(r-s)*(t-e)/(i-e)}function r(t,e,i){return t+i*(e-t)}function n(t,e,i){return(1-i)*t+i*e}var a=Object.freeze({__proto__:null,remapRange:s,lerp:r,lerpPrecise:n,log:function(t,e){switch(e){case 2:return Math.log(t)/Math.LN2;case 10:return Math.log(t)/Math.LN10;default:return Math.log(t)/Math.log(e)}}});class h{constructor(t,e){this.x=t,this.y=e}static get ZERO(){return new h(0,0)}static get ONE(){return new h(1,1)}static get UNIT_X(){return new h(1,0)}static get UNIT_Y(){return new h(0,1)}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x**2+this.y**2}normalize(){const t=1/this.length();return this.x*=t,this.y*=t,this}copy(t){this.x=t.x,this.y=t.y}clone(){return new h(this.x,this.y)}toArray(){return[this.x,this.y]}toString(){return`(${this.x}, ${this.y})`}static distanceSquared(t,e){return(t.x-e.x)**2+(t.y-e.y)**2}static distance(t,e){return Math.sqrt(h.distanceSquared(t,e))}static dot(t,e){return t.x*e.x+t.y*e.y}static lerp(t,e,i){const s=r(t.x,e.x,i),n=r(t.y,e.y,i);return new h(s,n)}static lerpPrecise(t,e,i){const s=n(t.x,e.x,i),r=n(t.y,e.y,i);return new h(s,r)}static polarToCartesian(t,e){return new h(t*Math.cos(e),t*Math.sin(e))}static fromAngle(t){return h.polarToCartesian(1,t)}static random(){return h.fromAngle(Math.random()*Math.PI*2)}static add(t,e){const i=t.x+e.x,s=t.y+e.y;return new h(i,s)}static subtract(t,e){const i=t.x-e.x,s=t.y-e.y;return new h(i,s)}static multiply(t,e){const i=t.x*e.x,s=t.y*e.y;return new h(i,s)}static divide(t,e){const i=t.x/e.x,s=t.y/e.y;return new h(i,s)}static addScalar(t,e){const i=t.x+e,s=t.y+e;return new h(i,s)}static subtractScalar(t,e){const i=t.x-e,s=t.y-e;return new h(i,s)}static multiplyScalar(t,e){const i=t.x*e,s=t.y*e;return new h(i,s)}static divideScalar(t,e){const i=t.x/e,s=t.y/e;return new h(i,s)}static transform(t,e){const i=t.x*e.data[0]+t.y*e.data[4]+e.data[12],s=t.x*e.data[1]+t.y*e.data[5]+e.data[13];return new h(i,s)}}class o{constructor(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y-this.height}intersects(t){return this.left<t.right&&this.right>t.left&&this.top>t.bottom&&this.bottom<t.top}completelyWithin(t){return this.left>=t.left&&this.right<=t.right&&this.bottom>=t.bottom&&this.top<=t.top}getResolution(t){const e=[new h(this.left,this.top),new h(this.right,this.top),new h(this.right,this.bottom),new h(this.left,this.bottom)],s=[new i(e[0].x,e[0].y,e[1].x,e[1].y),new i(e[1].x,e[1].y,e[2].x,e[2].y)],r=[new h(t.left,t.top),new h(t.right,t.top),new h(t.right,t.bottom),new h(t.left,t.bottom)];return l({vertices:e,edges:s},{vertices:r,edges:[new i(r[0].x,r[0].y,r[1].x,r[1].y),new i(r[1].x,r[1].y,r[2].x,r[2].y)]})}}function l(t,e){const i=c(t.vertices),s=c(e.vertices);if(!i.intersects(s))return new h(0,0);const r=d(t,e),n=d(e,t);if(null===r||null===n)return new h(0,0);const a=r.overlap<n.overlap?r:n,o=new h(-(a.edge.y2-a.edge.y1),a.edge.x2-a.edge.x1),l=o.length(),u=Math.acos(h.dot(o,new h(1,0))/l),w=Math.round(l*Math.cos(u)),p=Math.round(l*Math.sin(u)),f=i.left>s.left?1:-1,g=i.bottom>s.bottom?1:-1,y=0===w?0:a.overlap/w*f,m=0===p?0:a.overlap/p*g;return new h(y,m)}function c(t){let e=t[0].x,i=e,s=t[0].y,r=s;for(let n=1;n<t.length;n++)e=Math.min(e,t[n].x),i=Math.max(i,t[n].x),s=Math.min(s,t[n].y),r=Math.max(r,t[n].y);return new o(e,r,i-e,r-s)}function d(t,e){let s=new i(0,0,0,0),r=Number.MAX_SAFE_INTEGER;for(let i=0;i<t.edges.length;i++){const n=new h(-(t.edges[i].y2-t.edges[i].y1),t.edges[i].x2-t.edges[i].x1);let a=h.dot(t.vertices[0],n),o=a;for(let e=1;e<t.vertices.length;e++){const i=h.dot(t.vertices[e],n);a=Math.min(a,i),o=Math.max(o,i)}let l=h.dot(e.vertices[0],n),c=l;for(let t=1;t<e.vertices.length;t++){const i=h.dot(e.vertices[t],n);l=Math.min(l,i),c=Math.max(c,i)}const d=Math.min(o,c)-Math.max(a,l);if(d<r&&(r=d,s=t.edges[i]),c<a||o<l)return null}return{edge:s,overlap:r}}var u,w,p,f=Object.freeze({__proto__:null,getResolution:l}),g=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},y=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class m{constructor(t,e,i){u.set(this,void 0),w.set(this,void 0),p.set(this,void 0),g(this,u,t),g(this,w,e),g(this,p,new Array(y(this,u)*y(this,w)).fill(0)),void 0!==i&&this.setData(i)}get rows(){return y(this,u)}get columns(){return y(this,w)}get data(){return y(this,p)}get(t,e){return this.data[this.columns*e+t]}setData(t){if(t.length!==this.rows*this.columns)throw new TypeError("The given data does not match the dimensions of the matrix.");g(this,p,t.slice(0))}set(t,e,i){y(this,p)[this.columns*e+t]=i}transpose(){const t=new Array(this.rows*this.columns).fill(0),e=this.columns,i=this.rows;for(let s=0;s<e;s++)for(let e=0;e<i;e++)t[i*s+e]=this.data[this.columns*e+s];g(this,p,t)}toString(){let t="";for(let e=0;e<y(this,p).length;e+=this.columns){t+="("+y(this,p)[e];for(let i=1;i<this.columns;i++)t+=" "+y(this,p)[e+i];t+=")",e!==y(this,p).length-this.columns&&(t+=" ")}return t}static add(t,e){if(t.rows!==e.rows||t.columns!==e.columns)throw new TypeError("Both matrices are not the same size; cannot perform operation.");const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]+=e.data[s];return new m(t.rows,t.columns,i)}static subtract(t,e){if(t.rows!==e.rows||t.columns!==e.columns)throw new TypeError("Both matrices are not the same size; cannot perform operation.");const i=t.data.slice(0);for(let s=0;s<t.rows*t.columns;s++)i[s]-=e.data[s];return new m(t.rows,e.rows,i)}static multiply(t,e){if(t.columns!==e.rows)throw new TypeError(`Matrix b must have ${t.columns} rows; cannot multiply matrices.`);const i=new m(t.rows,e.columns);for(let s=0;s<t.rows;s++)for(let r=0;r<e.columns;r++){let n=0;for(let i=0;i<t.columns;i++)n+=t.get(i,s)*e.get(r,i);i.set(r,s,n)}return i}static addScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]+=e;return new m(t.rows,t.columns,i)}static subtractScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]-=e;return new m(t.rows,t.columns,i)}static multiplyScalar(t,e){const i=t.data.slice(0);for(let s=0;s<t.data.length;s++)i[s]*=e;return new m(t.rows,t.columns,i)}static divideScalar(t,e){const i=1/e;return m.multiplyScalar(t,i)}}u=new WeakMap,w=new WeakMap,p=new WeakMap;class v{constructor(t,e,i){this.x=t,this.y=e,this.z=i}static get ZERO(){return new v(0,0,0)}static get ONE(){return new v(1,1,1)}static get UNIT_X(){return new v(1,0,0)}static get UNIT_Y(){return new v(0,1,0)}static get UNIT_Z(){return new v(0,0,1)}static get LEFT(){return new v(-1,0,0)}static get UP(){return new v(0,1,0)}static get RIGHT(){return new v(1,0,0)}static get DOWN(){return new v(0,-1,0)}static get FORWARD(){return new v(0,0,-1)}static get BACKWARD(){return new v(0,0,1)}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.x**2+this.y**2+this.z**2}normalize(){const t=1/this.length();return this.x*=t,this.y*=t,this.z*=t,this}copy(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(){return new v(this.x,this.y,this.z)}toArray(){return[this.x,this.y,this.z]}toString(){return`(${this.x}, ${this.y}, ${this.z})`}static distanceSquared(t,e){return(t.x-e.x)**2+(t.y-e.y)**2+(t.z-e.z)**2}static distance(t,e){return Math.sqrt(v.distanceSquared(t,e))}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static lerp(t,e,i){const s=r(t.x,e.x,i),n=r(t.y,e.y,i),a=r(t.z,e.z,i);return new v(s,n,a)}static lerpPrecise(t,e,i){const s=n(t.x,e.x,i),r=n(t.y,e.y,i),a=n(t.z,e.z,i);return new v(s,r,a)}static sphericalToCartesian(t,e,i){return new v(t*Math.sin(i)*Math.cos(e),t*Math.sin(i)*Math.sin(e),t*Math.cos(i))}static cross(t,e){const i=t.y*e.z-e.y*t.z,s=t.z*e.x-e.z*t.x,r=t.x*e.y-e.x*t.y;return new v(i,s,r)}static add(t,e){const i=t.x+e.x,s=t.y+e.y,r=t.z+e.z;return new v(i,s,r)}static subtract(t,e){const i=t.x-e.x,s=t.y-e.y,r=t.z-e.z;return new v(i,s,r)}static multiply(t,e){const i=t.x*e.x,s=t.y*e.y,r=t.z*e.z;return new v(i,s,r)}static divide(t,e){const i=t.x/e.x,s=t.y/e.y,r=t.z/e.z;return new v(i,s,r)}static addScalar(t,e){const i=t.x+e,s=t.y+e,r=t.z+e;return new v(i,s,r)}static subtractScalar(t,e){const i=t.x-e,s=t.y-e,r=t.z-e;return new v(i,s,r)}static multiplyScalar(t,e){const i=t.x*e,s=t.y*e,r=t.z*e;return new v(i,s,r)}static divideScalar(t,e){const i=t.x/e,s=t.y/e,r=t.z/e;return new v(i,s,r)}static transform(t,e){const i=t.x*e.data[0]+t.y*e.data[4]+t.z*e.data[8]+e.data[12],s=t.x*e.data[1]+t.y*e.data[5]+t.z*e.data[9]+e.data[13],r=t.x*e.data[2]+t.y*e.data[6]+t.z*e.data[10]+e.data[14];return new v(i,s,r)}}var E,b,T,x=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},M=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class _{constructor(t){E.set(this,void 0),b.set(this,void 0),T.set(this,void 0),x(this,E,4),x(this,b,4),x(this,T,new Array(M(this,E)*M(this,b)).fill(0)),void 0!==t&&this.setData(t)}get rows(){return M(this,E)}get columns(){return M(this,b)}get data(){return M(this,T)}static get IDENTITY(){return new _([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}setData(t){if(t.length!==M(this,E)*M(this,b))throw new TypeError("The given data does not match the dimensions of the matrix.");x(this,T,t.slice(0))}get(t,e){return M(this,T)[M(this,b)*e+t]}set(t,e,i){M(this,T)[M(this,b)*e+t]=i}transpose(){const t=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];t[0]=M(this,T)[0],t[1]=M(this,T)[4],t[2]=M(this,T)[8],t[3]=M(this,T)[12],t[4]=M(this,T)[1],t[5]=M(this,T)[5],t[6]=M(this,T)[9],t[7]=M(this,T)[13],t[8]=M(this,T)[2],t[9]=M(this,T)[6],t[10]=M(this,T)[10],t[11]=M(this,T)[14],t[12]=M(this,T)[3],t[13]=M(this,T)[7],t[14]=M(this,T)[11],t[15]=M(this,T)[15],x(this,T,t)}toString(){return`(${this.data[0]}, ${this.data[1]}, ${this.data[2]}, ${this.data[3]}) (${this.data[4]}, ${this.data[5]}, ${this.data[6]}, ${this.data[7]}) (${this.data[8]}, ${this.data[9]}, ${this.data[10]}, ${this.data[11]}) (${this.data[12]}, ${this.data[13]}, ${this.data[14]}, ${this.data[15]})`}static add(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]+=e.data[t];return new _(i)}static subtract(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]-=e.data[t];return new _(i)}static multiply(t,e){const i=new Array(16).fill(0);return i[0]=t.data[0]*e.data[0]+t.data[1]*e.data[4]+t.data[2]*e.data[8]+t.data[3]*e.data[12],i[1]=t.data[0]*e.data[1]+t.data[1]*e.data[5]+t.data[2]*e.data[9]+t.data[3]*e.data[13],i[2]=t.data[0]*e.data[2]+t.data[1]*e.data[6]+t.data[2]*e.data[10]+t.data[3]*e.data[14],i[3]=t.data[0]*e.data[3]+t.data[1]*e.data[7]+t.data[2]*e.data[11]+t.data[3]*e.data[15],i[4]=t.data[4]*e.data[0]+t.data[5]*e.data[4]+t.data[6]*e.data[8]+t.data[7]*e.data[12],i[5]=t.data[4]*e.data[1]+t.data[5]*e.data[5]+t.data[6]*e.data[9]+t.data[7]*e.data[13],i[6]=t.data[4]*e.data[2]+t.data[5]*e.data[6]+t.data[6]*e.data[10]+t.data[7]*e.data[14],i[7]=t.data[4]*e.data[3]+t.data[5]*e.data[7]+t.data[6]*e.data[11]+t.data[7]*e.data[15],i[8]=t.data[8]*e.data[0]+t.data[9]*e.data[4]+t.data[10]*e.data[8]+t.data[11]*e.data[12],i[9]=t.data[8]*e.data[1]+t.data[9]*e.data[5]+t.data[10]*e.data[9]+t.data[11]*e.data[13],i[10]=t.data[8]*e.data[2]+t.data[9]*e.data[6]+t.data[10]*e.data[10]+t.data[11]*e.data[14],i[11]=t.data[8]*e.data[3]+t.data[9]*e.data[7]+t.data[10]*e.data[11]+t.data[11]*e.data[15],i[12]=t.data[12]*e.data[0]+t.data[13]*e.data[4]+t.data[14]*e.data[8]+t.data[15]*e.data[12],i[13]=t.data[12]*e.data[1]+t.data[13]*e.data[5]+t.data[14]*e.data[9]+t.data[15]*e.data[13],i[14]=t.data[12]*e.data[2]+t.data[13]*e.data[6]+t.data[14]*e.data[10]+t.data[15]*e.data[14],i[15]=t.data[12]*e.data[3]+t.data[13]*e.data[7]+t.data[14]*e.data[11]+t.data[15]*e.data[15],new _(i)}static addScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]+=e;return new _(i)}static subtractScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]-=e;return new _(i)}static multiplyScalar(t,e){const i=t.data.slice(0);for(let t=0;t<i.length;t++)i[t]*=e;return new _(i)}static divideScalar(t,e){const i=1/e;return _.multiplyScalar(t,i)}static createRotationX(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[5]=Math.cos(t),e[6]=Math.sin(t),e[9]=-Math.sin(t),e[10]=Math.cos(t),new _(e)}static createRotationY(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[0]=Math.cos(t),e[2]=-Math.sin(t),e[8]=Math.sin(t),e[10]=Math.cos(t),new _(e)}static createRotationZ(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[0]=Math.cos(t),e[1]=Math.sin(t),e[4]=-Math.sin(t),e[5]=Math.cos(t),new _(e)}static createTranslation(t,e,i){const s=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return s[12]=t,s[13]=e,s[14]=i,new _(s)}static createScale(t,e,i){const s=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return s[0]=t,s[5]=e,s[10]=i,new _(s)}static createOrthographic(t,e,i,s){const r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],n=1/(s-i);return r[0]=2/t,r[5]=2/e,r[10]=-2*n,r[14]=-(s+i)*n,new _(r)}static createOrthographicOffCenter(t,e,i,s,r,n){const a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],h=1/(e-t),o=1/(s-i),l=1/(n-r);return a[0]=2*h,a[5]=2*o,a[10]=-2*l,a[12]=-(e+t)*h,a[13]=-(s+i)*o,a[14]=-(n+r)*l,a[15]=1,new _(a)}static createPerspective(t,e,i,s){const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=1/(s-i);return r[0]=2*i/t,r[5]=2*i/e,r[10]=-(s+i)*n,r[11]=-1,r[14]=-2*s*i*n,new _(r)}static createPerspectiveOffCenter(t,e,i,s,r,n){const a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],h=1/(e-t),o=1/(s-i),l=1/(n-r);return a[0]=2*r*h,a[5]=2*r*o,a[8]=(e+t)*h,a[9]=(s+i)*o,a[10]=-(n+r)*l,a[11]=-1,a[14]=-2*n*r*l,new _(a)}static createLookAt(t,e,i){const s=v.subtract(t,e).normalize(),r=v.cross(i,s).normalize(),n=v.cross(s,r),a=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return a[0]=r.x,a[1]=n.x,a[2]=s.x,a[4]=r.y,a[5]=n.y,a[6]=s.y,a[8]=r.z,a[9]=n.z,a[10]=s.z,a[12]=-v.dot(r,t),a[13]=-v.dot(n,t),a[14]=-v.dot(s,t),new _(a)}}E=new WeakMap,b=new WeakMap,T=new WeakMap;var k,A=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},S=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function P(t){return function(){var e=t+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296}}k=new WeakMap;var W,R,O,L,I,z,N,B,D,G,U,C,j,F=Object.freeze({__proto__:null,roll:function(t){return!(t<=0)&&(t>=1||Math.random()<=t)},gaussian:function(t,e){const i=1-Math.random(),s=1-Math.random();return t+e*(Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*s))}}),V=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},X=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function $(t,e,i){const s=_.multiply;return s(s(t,e),i)}!function(t){t[t.None=0]="None",t[t.Orthographic=1]="Orthographic",t[t.Perspective=2]="Perspective"}(j||(j={}));W=new WeakMap,R=new WeakMap,O=new WeakMap,L=new WeakMap,I=new WeakMap,z=new WeakMap,N=new WeakMap,B=new WeakMap,D=new WeakMap,G=new WeakMap,U=new WeakMap,C=new WeakMap;class q{constructor(t,e,i){this.name=t,this.size=e,this.type=i,this.stride=-1,this.offset=-1,Object.defineProperty(this,"name",{writable:!1}),Object.defineProperty(this,"size",{writable:!1}),Object.defineProperty(this,"type",{writable:!1})}}const H={BYTE:5120,SHORT:5122,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FIXED:void 0,FLOAT:5126};Object.freeze(H);const Y={BYTE:1,SHORT:2,UNSIGNED_BYTE:1,UNSIGNED_SHORT:2,FIXED:void 0,FLOAT:4};Object.freeze(Y);class K{constructor(t){this.elements=t;const e=function(t){let e=0,i=0,s=[];for(let r of t)switch(e+=r.size,s.push(i),r.type){case H.FLOAT:i+=Y.FLOAT*r.size;break;default:throw new TypeError("Unsupported attribute type.")}for(let e=0;e<t.length;e++)t[e].stride=i,t[e].offset=s[e];return{size:e,stride:i}}(this.elements);this.size=e.size,this.stride=e.stride,Object.defineProperty(this,"elements",{writable:!1}),Object.defineProperty(this,"size",{writable:!1}),Object.defineProperty(this,"stride",{writable:!1})}}function Z(t,e,i){return function(t,e,i){const s=t.createProgram();if(null===s)throw new Error("Something went wrong; could not create WebGLProgram.");if(t.attachShader(s,e),t.attachShader(s,i),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS))throw new Error("An error occurred while initializing the shader program: "+t.getProgramInfoLog(s));return s}(t,tt(t,t.VERTEX_SHADER,e),tt(t,t.FRAGMENT_SHADER,i))}function Q(t,e,i,s){const r=t.createBuffer();if(null===r)throw new Error("Something went wrong; could not create WebGLBuffer.");return t.bindBuffer(e,r),t.bufferData(e,i,s),r}function J(t,e,i,s){t.bindBuffer(e,i),t.bufferSubData(e,0,s)}function tt(t,e,i){const s=t.createShader(e);if(null===s)throw new TypeError(`'${e}' is not a valid WebGL shader type.`);if(t.shaderSource(s,i),t.compileShader(s),!t.getShaderParameter(s,t.COMPILE_STATUS)){const e=new Error("An error occurred will compiling the shader: "+t.getShaderInfoLog(s));throw t.deleteShader(s),e}return s}function et(t){return 0==(t&t-1)}const it={VERTEX:0,INDEX:1};Object.freeze(it);var st,rt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},nt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class at{constructor(t,e,i){st.set(this,void 0),this.length=e,this.type=i,rt(this,st,t),this.data=null,this.buffer=null,Object.defineProperty(this,"length",{writable:!1}),Object.defineProperty(this,"type",{writable:!1})}setData(t){if(null===this.data||null===this.buffer)throw new Error("This buffer was not initialized correctly. Make sure the 'data' and 'buffer' properties are set..");if(null!=t){if(t.length>this.length)throw new TypeError(`Expected an array with ${this.length} element(s) or less.`);switch(this.data.set(t),this.type){case it.VERTEX:!function(t,e,i){J(t,t.ARRAY_BUFFER,e,i)}(nt(this,st).gl,this.buffer,this.data);break;case it.INDEX:!function(t,e,i){J(t,t.ELEMENT_ARRAY_BUFFER,e,i)}(nt(this,st).gl,this.buffer,this.data);break;default:throw new TypeError(`'${this.type}' is an invalid BufferType.`)}}}}st=new WeakMap;var ht,ot,lt,ct,dt=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ut=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class wt{constructor(t,e){switch(ht.set(this,void 0),ot.set(this,void 0),lt.set(this,void 0),ct.set(this,void 0),dt(this,ht,0),dt(this,ot,0),dt(this,lt,0),dt(this,ct,1),typeof t){case"number":dt(this,ht,this.validateValue(((16711680&t)>>16)/255)),dt(this,ot,this.validateValue(((65280&t)>>8)/255)),dt(this,lt,this.validateValue((255&t)/255));break;case"string":{let e=t.toLowerCase().trim();if(e="#"==e.substring(0,1)?e.substring(1):e,!/^[\da-f]{6}$/.test(e))throw new TypeError("The given string could not be parsed as a hexadecimal value.");const i=parseInt(e,16);dt(this,ht,this.validateValue(((16711680&i)>>16)/255)),dt(this,ot,this.validateValue(((65280&i)>>8)/255)),dt(this,lt,this.validateValue((255&i)/255));break}}void 0!==e&&this.multiply(this.validateValue(e))}get r(){return ut(this,ht)}set r(t){dt(this,ht,this.validateValue(t))}get g(){return ut(this,ot)}set g(t){dt(this,ot,this.validateValue(t))}get b(){return ut(this,lt)}set b(t){dt(this,lt,this.validateValue(t))}get a(){return ut(this,ct)}set a(t){dt(this,ct,this.validateValue(t))}fromRGB(t,e,i,s){return dt(this,ht,this.validateValue(t/255)),dt(this,ot,this.validateValue(e/255)),dt(this,lt,this.validateValue(i/255)),void 0!==s&&this.multiply(this.validateValue(s)),this}multiply(t){dt(this,ht,this.validateValue(ut(this,ht)*t)),dt(this,ot,this.validateValue(ut(this,ot)*t)),dt(this,lt,this.validateValue(ut(this,lt)*t)),dt(this,ct,this.validateValue(ut(this,ct)*t))}toArray(){return[ut(this,ht),ut(this,ot),ut(this,lt),ut(this,ct)]}toString(){const t=Math.floor(255*ut(this,ht)),e=Math.floor(255*ut(this,ot)),i=Math.floor(255*ut(this,lt));let s=t.toString(16);1===s.length&&(s="0"+s);let r=e.toString(16);1===r.length&&(r="0"+r);let n=i.toString(16);return 1===n.length&&(n="0"+n),`(${t} ${e} ${i}) ${ut(this,ct).toFixed(4)}, 0x${s}${r}${n}`}validateValue(t){return t<1/255?0:t>1?1:Math.floor(t/(1/255))*(1/255)}}ht=new WeakMap,ot=new WeakMap,lt=new WeakMap,ct=new WeakMap;const pt={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};Object.freeze(pt);class ft{constructor(t,e,i){this.program=Z(t.gl,e,i),Object.defineProperty(this,"program",{writable:!1})}}var gt,yt,mt,vt,Et=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},bt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Tt{constructor(t){gt.set(this,void 0),yt.set(this,void 0),mt.set(this,void 0),vt.set(this,void 0),this.gl=t,this.extensions={ANGLE_instanced_arrays:this.gl.getExtension("ANGLE_instanced_arrays")},Et(this,gt,null),Et(this,yt,-1),Et(this,mt,-1),Et(this,vt,-1),function(t){t.enable(t.BLEND),t.blendFunc(t.ONE,t.ONE_MINUS_SRC_ALPHA),t.clearDepth(1),t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL)}(this.gl),Object.defineProperty(this,"gl",{writable:!1}),Object.defineProperty(this,"extensions",{writable:!1})}get drawWidth(){return bt(this,yt)}get drawHeight(){return bt(this,mt)}get scale(){return bt(this,vt)}get isLandscape(){return bt(this,yt)>=bt(this,mt)}setCanvasDimensions(t,e){return this.gl.canvas.width=t,this.gl.canvas.height=e,this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),bt(this,yt)<0&&this.setResolution(t,e),this}setResolution(t,e){return Et(this,yt,Math.max(0,t)),Et(this,mt,Math.max(0,e)),this.isLandscape?(Et(this,vt,this.gl.canvas.height/bt(this,mt)),bt(this,yt)*bt(this,vt)>this.gl.canvas.width&&Et(this,vt,this.gl.canvas.width/bt(this,yt))):(Et(this,vt,this.gl.canvas.width/bt(this,yt)),bt(this,mt)*bt(this,vt)>this.gl.canvas.height&&Et(this,vt,this.gl.canvas.width/bt(this,yt))),this}clear(t){var e,i,s,r,n;e=this.gl,i=t.r,s=t.g,r=t.b,n=t.a,e.clearColor(i,s,r,n),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}begin(t){return Et(this,gt,t.program),this.gl.useProgram(bt(this,gt)),this}setVertexBuffer(...t){if(null===bt(this,gt))throw new Error("'begin(effect)' must be called before setting a VertexBuffer.");for(let e=0;e<t.length;e++){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,t[e].buffer);for(let i of t[e].attributeSchema.elements){const s=this.gl.getAttribLocation(bt(this,gt),i.name);if(s<0)throw new Error(`The current program does not have a(n) '${i.name}' attribute.`);this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,i.size,i.type,!1,i.stride,i.offset),this.extensions.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(s,t[e].instanceFrequency)}}return this}setIndexBuffer(t){return this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer),this}setUniform(t,e){if(null===bt(this,gt))throw new Error("'begin(effect)' must be called before setting a uniform.");const i=this.gl.getUniformLocation(bt(this,gt),t);return this.gl.uniformMatrix4fv(i,!1,e),this}setUniform2(t){if(null===bt(this,gt))throw new Error("'begin(effect)' must be called before setting a NULL.");const e=this.gl.getUniformLocation(bt(this,gt),t);return this.gl.uniform1i(e,0),this}setTexture(t){return this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this}drawArrays(t,e,i){return this.gl.drawArrays(t,e,i),this}drawElements(t,e,i){return this.gl.drawElements(t,3*e,this.gl.UNSIGNED_SHORT,i),this}drawInstancedElements(t,e,i,s){return this.extensions.ANGLE_instanced_arrays.drawElementsInstancedANGLE(t,3*e,this.gl.UNSIGNED_SHORT,i,s),this}disableVertexBuffer(...t){if(null===bt(this,gt))throw new Error("'begin(effect)' must be called before deleting a Buffer.");for(let e=0;e<t.length;e++)for(let i of t[e].attributeSchema.elements){const t=this.gl.getAttribLocation(bt(this,gt),i.name);if(t<0)throw new Error(`The current program does not have a(n) '${i.name}' attribute.`);this.gl.disableVertexAttribArray(t)}return this}end(){Et(this,gt,null)}}gt=new WeakMap,yt=new WeakMap,mt=new WeakMap,vt=new WeakMap;class xt extends at{constructor(t,e){var i,s;super(t,e,it.INDEX),this.data=new Int16Array(this.length),this.buffer=(i=t.gl,s=this.data.byteLength,Q(i,i.ELEMENT_ARRAY_BUFFER,s,i.STATIC_DRAW))}}class Mt{constructor(t,e){this.vertices=t,this.indices=e,this.totalVertices=t.length/3,this.totalIndices=e.length,Object.defineProperty(this,"vertices",{writable:!1}),Object.defineProperty(this,"indices",{writable:!1}),Object.defineProperty(this,"totalVertices",{writable:!1}),Object.defineProperty(this,"totalIndices",{writable:!1})}}var _t,kt,At,St=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Pt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Wt{constructor(t,e){_t.set(this,void 0),kt.set(this,void 0),At.set(this,void 0),St(this,_t,0),St(this,kt,0),St(this,At,null),void 0!==t&&St(this,_t,t),void 0!==e&&St(this,kt,e)}get width(){return Pt(this,_t)}get height(){return Pt(this,kt)}get data(){return Pt(this,At)}setPixels(t,e){St(this,At,function(t,e,i,s){const r=t.createTexture();if(null===r)throw new Error("Something went wrong; could not create WebGLTexture.");return t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,i,0,t.RGBA,t.UNSIGNED_BYTE,s),et(e)&&et(i)?t.generateMipmap(t.TEXTURE_2D):(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST)),r}(t.gl,Pt(this,_t),this.height,e))}static async fromURL(t,e){const i=await async function(t){return new Promise((e,i)=>{try{const i=new Image;i.onload=()=>{e(i)},i.src=t}catch(t){i(t)}})}(e),s=function(t,e){const i=t.createTexture();if(null===i)throw new Error("Something went wrong; could not create WebGLTexture.");return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),et(e.width)&&et(e.height)?t.generateMipmap(t.TEXTURE_2D):(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST)),i}(t.gl,i),r=new Wt(i.width,i.height);return St(r,At,s),r}}_t=new WeakMap,kt=new WeakMap,At=new WeakMap;class Rt extends at{constructor(t,e,i,s,r){var n,a,h;super(t,i,it.VERTEX),this.attributeSchema=e,this.vertexUsage=s,this.instanceFrequency=r||0,this.data=new Float32Array(this.length),this.buffer=(n=t.gl,a=this.data.byteLength,h=this.vertexUsage,Q(n,n.ARRAY_BUFFER,a,h)),Object.defineProperty(this,"attributeSchema",{writable:!1}),Object.defineProperty(this,"vertexUsage",{writable:!1}),Object.defineProperty(this,"instanceFrequency",{writable:!1})}}const Ot={STREAM:35040,STATIC:35044,DYNAMIC:35048};Object.freeze(Ot);class Lt{constructor(t){this.gamepad=t,Object.defineProperty(this,"gamepad",{writable:!1})}}const It=new Map,zt=new Map;function Nt(t,e){const i=t.toLocaleLowerCase().split(",");for(let t=0;t<i.length;t++){const s=i[t].trim();if(zt.has(s)){const t=zt.get(s);if(e.gamepad.buttons[t].pressed&&e.gamepad.buttons[t].value>0)return!0}}return!1}zt.set("a",0),zt.set("b",1),zt.set("x",2),zt.set("y",3),zt.set("leftbumper",4),zt.set("rightbumper",5),zt.set("lefttrigger",6),zt.set("righttrigger",7),zt.set("back",8),zt.set("start",9),zt.set("leftstick",10),zt.set("rightstick",11),zt.set("dpadup",12),zt.set("dpaddown",13),zt.set("dpadleft",14),zt.set("dpadright",15),window.addEventListener("gamepadconnected",t=>{It.set(t.gamepad.index,t.gamepad)}),window.addEventListener("gamepaddisconnected",t=>{It.delete(t.gamepad.index)});class Bt{constructor(t,e){this.event=t,this.keysPressed=new Set(e),Object.defineProperty(this,"event",{writable:!1}),Object.defineProperty(this,"keysPressed",{writable:!1})}}const Dt=new Set;let Gt=null;function Ut(t,e){const i=t.toLocaleLowerCase().split(",");for(let t=0;t<i.length;t++)if(e.keysPressed.has(i[t].trim()))return!0;return!1}window.addEventListener("keydown",t=>{Gt=t,t.repeat||Dt.add(t.key.toLocaleLowerCase())}),window.addEventListener("keyup",t=>{Gt=t,Dt.delete(t.key.toLocaleLowerCase())}),window.addEventListener("blur",()=>{Gt=null,Dt.clear()});var Ct,jt,Ft=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Vt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Xt{constructor(){Ct.set(this,void 0),jt.set(this,void 0),Ft(this,Ct,null),Ft(this,jt,null)}pressed(t){return null!==Vt(this,Ct)&&null!==Vt(this,jt)&&(!Ut(t,Vt(this,Ct))&&Ut(t,Vt(this,jt)))}pressing(t){return null!==Vt(this,jt)&&Ut(t,Vt(this,jt))}update(){Ft(this,Ct,Vt(this,jt)),Ft(this,jt,null===Gt?null:new Bt(Gt,Dt))}}Ct=new WeakMap,jt=new WeakMap;var $t,qt,Ht=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Yt=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Kt{constructor(t){$t.set(this,void 0),qt.set(this,void 0),this.playerIndex=t,Ht(this,$t,null),Ht(this,qt,null),Object.defineProperty(this,"playerIndex",{writable:!1})}get connected(){return null!==Yt(this,qt)}get description(){return null===Yt(this,qt)?"":Yt(this,qt).gamepad.id}get leftStickAxes(){return null===Yt(this,qt)?{x:0,y:0}:{x:Yt(this,qt).gamepad.axes[0],y:-Yt(this,qt).gamepad.axes[1]}}get rightStickAxes(){return null===Yt(this,qt)?{x:0,y:0}:{x:Yt(this,qt).gamepad.axes[2],y:-Yt(this,qt).gamepad.axes[3]}}get buttons(){return null===Yt(this,qt)?[]:Yt(this,qt).gamepad.axes}pressed(t){return null!==Yt(this,$t)&&null!==Yt(this,qt)&&(!Nt(t,Yt(this,$t))&&Nt(t,Yt(this,qt)))}pressing(t){return null!==Yt(this,qt)&&Nt(t,Yt(this,qt))}update(){var t;Ht(this,$t,Yt(this,qt)),Ht(this,qt,(t=this.playerIndex,It.has(t)?new Lt(It.get(t)):null))}}$t=new WeakMap,qt=new WeakMap;class Zt{constructor(t){this.event=t,Object.defineProperty(this,"event",{writable:!1})}}let Qt=null;function Jt(t,e){const i=t.toLocaleLowerCase().split(","),s=new Set(i);let r=0;for(let t of s)switch(t.trim()){case"leftclick":r+=1;break;case"rightclick":r+=2;break;case"middleclick":r+=4}return 0!=(e.event.buttons&r)}window.addEventListener("pointermove",t=>{Qt=t}),window.addEventListener("pointerdown",t=>{Qt=t}),window.addEventListener("pointerup",t=>{Qt=t}),window.addEventListener("blur",()=>{Qt=null});var te,ee,ie,se,re,ne=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ae=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class he{constructor(){te.set(this,void 0),ee.set(this,void 0),ie.set(this,void 0),se.set(this,void 0),re.set(this,void 0),ne(this,te,null),ne(this,ee,null),ne(this,ie,null),ne(this,se,0),ne(this,re,0)}get x(){return ae(this,se)}get y(){return ae(this,re)}attachElement(t){ne(this,te,t)}pressed(t){return null!==ae(this,ee)&&null!==ae(this,ie)&&(!Jt(t,ae(this,ee))&&Jt(t,ae(this,ie)))}pressing(t){return null!==ae(this,ie)&&Jt(t,ae(this,ie))}update(){ne(this,ee,ae(this,ie)),ne(this,ie,null===Qt?null:new Zt(Qt)),null!==ae(this,te)&&null!==ae(this,ie)&&(ne(this,se,ae(this,ie).event.clientX-ae(this,te).offsetLeft),ne(this,re,ae(this,ie).event.clientY-ae(this,te).offsetTop))}}te=new WeakMap,ee=new WeakMap,ie=new WeakMap,se=new WeakMap,re=new WeakMap;var oe,le,ce,de,ue,we=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},pe=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};oe=new WeakMap,le=new WeakMap,ce=new WeakMap,de=new WeakMap,ue=new WeakMap;var fe,ge,ye,me=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ve=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Ee{constructor(t,e,i,s){fe.set(this,void 0),ge.set(this,void 0),ye.set(this,void 0),this.name=t,me(this,fe,""),me(this,ge,""),me(this,ye,""),void 0!==e&&me(this,fe,e),void 0!==i&&me(this,ge,i),void 0!==s&&me(this,ye,s),Object.defineProperty(this,"name",{writable:!1})}get keys(){return ve(this,fe)}get gamepadButtons(){return ve(this,ge)}get mouseButtons(){return ve(this,ye)}remapKeys(t){me(this,fe,t)}remapGamepadButtons(t){me(this,ge,t)}remapMouseButtons(t){me(this,ye,t)}}fe=new WeakMap,ge=new WeakMap,ye=new WeakMap;var be,Te=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},xe=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function Me(t){return t.toLocaleLowerCase()}be=new WeakMap;const _e=function(){const t=!!window.opr&&!!opr.addons||!!window.opera||navigator.userAgent.indexOf(" OPR/")>=0,e="undefined"!=typeof InstallTrigger,i=/constructor/i.test(window.HTMLElement)||"[object SafariRemoteNotification]"===(!window.safari||"undefined"!=typeof safari&&safari.pushNotification).toString(),s=/*@cc_on!@*/!!document.documentMode,r=!s&&!!window.StyleMedia,n=!(!window.chrome||!window.chrome.webstore&&!window.chrome.runtime&&!window.chrome.csi),a=n&&-1!=navigator.userAgent.indexOf("Edg"),h=(n||t)&&!!window.CSS;let o="";return o=t?"opera":o,o=e?"firefox":o,o=i?"safari":o,o=s?"ie":o,o=r?"edge":o,o=n?"chrome":o,o=a?"edgechromium":o,{browserName:o,isBlink:h}}().isBlink;var ke,Ae=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Se=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function Pe(t){return t.toLocaleLowerCase()}class We{constructor(){ke.set(this,void 0),Ae(this,ke,new Map)}get length(){return Se(this,ke).entries.length}get entries(){return Se(this,ke).entries}register(t,e){const i=Pe(t);if(Se(this,ke).has(i))throw new TypeError("An entry with that name already exists; try a different name.");Se(this,ke).set(i,e)}get(t){const e=Pe(t);if(!Se(this,ke).has(e))throw new TypeError("An entry with that name has not been registered.");return Se(this,ke).get(e)}remove(t){const e=Pe(t);if(!Se(this,ke).has(e))throw new TypeError("An entry with that name has not been registered.");Se(this,ke).delete(e)}}ke=new WeakMap;var Re,Oe,Le,Ie,ze=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Ne=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Be{constructor(t){if(Re.set(this,void 0),Oe.set(this,void 0),Le.set(this,void 0),Ie.set(this,void 0),t<0)throw new TypeError("The range must be greater than or equal to zero.");ze(this,Le,t),ze(this,Ie,0),ze(this,Oe,new Array(Ne(this,Le)).fill(0)),ze(this,Re,new Array(Ne(this,Le)).fill(0))}get size(){return Ne(this,Ie)}get values(){return function*(t){for(let e=0;e<t.length;e++)yield t[e]}(Ne(this,Re).slice(0,Ne(this,Ie)))}has(t){if(t<0)throw new TypeError("The 'value' parameter must be a positive number.");return t<Ne(this,Le)&&Ne(this,Oe)[t]<Ne(this,Ie)&&Ne(this,Re)[Ne(this,Oe)[t]]===t}add(t){if(t>=Ne(this,Le))throw new TypeError("The 'value' parameter cannot be greater than or equal to the SparseSet's range.");return!this.has(t)&&(Ne(this,Re)[Ne(this,Ie)]=t,Ne(this,Oe)[t]=Ne(this,Ie),ze(this,Ie,+Ne(this,Ie)+1),!0)}delete(t){if(!this.has(t))return!1;ze(this,Ie,+Ne(this,Ie)-1);for(let e=Ne(this,Re).indexOf(t);e<Ne(this,Ie);e++)Ne(this,Re)[e]=Ne(this,Re)[e+1],Ne(this,Oe)[Ne(this,Re)[e+1]]=e;return!0}clear(){ze(this,Ie,0)}*[(Re=new WeakMap,Oe=new WeakMap,Le=new WeakMap,Ie=new WeakMap,Symbol.iterator)](){for(let t=0;t<Ne(this,Ie);t++)yield Ne(this,Re)[t]}}var De,Ge,Ue,Ce=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},je=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Fe{constructor(){De.set(this,void 0),Ge.set(this,void 0),Ue.set(this,void 0),this.scenes=new We,Ce(this,De,!1),Ce(this,Ge,null),Ce(this,Ue,null),Object.defineProperty(this,"scenes",{writable:!1}),Object.defineProperty(this,"graphics",{writable:!1})}register(...t){for(let e=0;e<t.length;e++)this.scenes.register(t[e].name,t[e]);return this}queue(t){const e=this.scenes.get(t);if(void 0===e)throw new Error("Something went wrong!");Ce(this,Ue,e),Ce(this,De,!0)}update(t){var e;this.updateTransitions(),null===(e=je(this,Ge))||void 0===e||e.update(t)}draw(t,e){var i;null===(i=je(this,Ge))||void 0===i||i.draw(t,e)}updateTransitions(){var t,e;je(this,De)&&(null===(t=je(this,Ge))||void 0===t||t.onExit(),null===(e=je(this,Ue))||void 0===e||e.onEnter(),Ce(this,Ge,je(this,Ue)),Ce(this,De,!1))}}De=new WeakMap,Ge=new WeakMap,Ue=new WeakMap;const Ve=new Mt([0,0,0,1,0,0,1,-1,0,0,-1,0],[0,3,1,1,3,2]),Xe=function(){const t=Math.sqrt(3)/2;return new Mt([1-t,0,0,1,-.5,0,1-t,-1,0],[0,2,1])}(),$e=function(t){if(t<=2)throw new TypeError("A polygon must have at least 3 vertices.");const e=2*Math.PI,i=[],s=[],r=3*(t-2),n=e/t;for(let s=e;s>=0&&(i.push(.5+.5*Math.cos(s)),i.push(.5*Math.sin(s)-.5),i.push(0),!(i.length>=3*t));s-=n);let a=1;for(let t=0;t<r;t+=3)s.push(0),s.push(a+1),s.push(a),a++;return new Mt(i,s)}(90);const qe=new K([new q("a_vertexPosition",3,H.FLOAT)]);class He{constructor(t,e){this.vertexBuffer=new Rt(t,qe,e.vertices.length,Ot.STATIC),this.indexBuffer=new xt(t,e.indices.length),this.totalVertices=e.totalVertices,this.totalTriangles=e.totalIndices/3,this.vertexBuffer.setData(e.vertices),this.indexBuffer.setData(e.indices),Object.defineProperty(this,"vertexBuffer",{writable:!1}),Object.defineProperty(this,"indexBuffer",{writable:!1}),Object.defineProperty(this,"totalVertices",{writable:!1}),Object.defineProperty(this,"totalTriangles",{writable:!1})}}var Ye,Ke,Ze=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Qe=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Je{constructor(t){Ye.set(this,void 0),Ke.set(this,void 0),Ze(this,Ye,t),Ze(this,Ke,new We),this.createDefaults()}registerGeometry(t,e){return Qe(this,Ke).register(t,e),this}getGeometry(t){return Qe(this,Ke).get(t)}removeGeometry(t){return Qe(this,Ke).remove(t),this}createDefaults(){this.registerGeometry("Susurrus_Circle",new He(Qe(this,Ye),$e)),this.registerGeometry("Susurrus_Square",new He(Qe(this,Ye),Ve)),this.registerGeometry("Susurrus_Triangle",new He(Qe(this,Ye),Xe))}}Ye=new WeakMap,Ke=new WeakMap;var ti,ei,ii,si,ri,ni,ai,hi,oi,li,ci,di,ui,wi,pi,fi,gi=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},yi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};const mi=new K([new q("a_translation",3,H.FLOAT),new q("a_scale",3,H.FLOAT),new q("a_rotationOffset",3,H.FLOAT),new q("a_rotation",1,H.FLOAT),new q("a_color",4,H.FLOAT)]);class vi{constructor(t,e,i,s,r){ti.set(this,void 0),ei.set(this,void 0),ii.set(this,void 0),si.set(this,void 0),ri.set(this,void 0),ni.set(this,void 0),ai.set(this,void 0),hi.set(this,void 0),oi.set(this,void 0),li.set(this,void 0),ci.set(this,void 0),di.set(this,void 0),ui.set(this,void 0),wi.set(this,void 0),pi.set(this,void 0),fi.set(this,void 0),gi(this,ti,t),gi(this,ii,null),gi(this,ei,null),gi(this,ri,e),gi(this,ni,i),gi(this,ai,0),gi(this,hi,s),gi(this,oi,r),gi(this,li,new v(0,0,0)),gi(this,ci,new v(1,1,1)),gi(this,di,new v(0,0,0)),gi(this,ui,0),gi(this,wi,new wt(16777215)),gi(this,pi,!1),gi(this,fi,!1),gi(this,si,null)}get x(){return yi(this,ri)}set x(t){t!==yi(this,ri)&&(gi(this,ri,t),gi(this,fi,!0))}get y(){return yi(this,ni)}set y(t){t!==yi(this,ni)&&(gi(this,ni,t),gi(this,fi,!0))}get z(){return yi(this,ai)}set z(t){t!==yi(this,ai)&&(gi(this,ai,t),gi(this,fi,!0))}get width(){return yi(this,hi)}set width(t){t!==yi(this,hi)&&(gi(this,hi,t),gi(this,fi,!0))}get height(){return yi(this,oi)}set height(t){t!==yi(this,oi)&&(gi(this,oi,t),gi(this,fi,!0))}get translation(){return yi(this,li)}set translation(t){t!==yi(this,li)&&(gi(this,li,t),gi(this,fi,!0))}get scale(){return yi(this,ci)}set scale(t){t!==yi(this,ci)&&(gi(this,ci,t),gi(this,fi,!0))}get rotationOffset(){return yi(this,di)}set rotationOffset(t){t!==yi(this,di)&&(gi(this,di,t),gi(this,fi,!0))}get rotation(){return yi(this,ui)}set rotation(t){t!==yi(this,ui)&&(gi(this,ui,t),gi(this,fi,!0))}get color(){return yi(this,wi)}set color(t){t!==yi(this,wi)&&(gi(this,wi,t),gi(this,fi,!0))}get position(){return new v(yi(this,ri),yi(this,ni),yi(this,ai))}get aabb(){return new o(yi(this,ri),yi(this,ni),yi(this,hi),yi(this,oi))}setPosition(t,e,i){return gi(this,ri,t),gi(this,ni,e),gi(this,ai,i),gi(this,fi,!0),this}attachMesh(t){return gi(this,ti,t),gi(this,pi,!0),this}attachGeometry(t){return gi(this,ii,t),this}attachEffect(t){return gi(this,si,t),this}createGeometry(t){return gi(this,ii,new He(t,yi(this,ti))),this}createModelBuffer(t){gi(this,pi,!1);let e=mi.size;return _e&&(e*=yi(this,ti).totalVertices),gi(this,ei,new Rt(t,mi,e,Ot.DYNAMIC,1)),this.updateModelBuffer(),this}calculateTransform(){const t=_.createScale(this.width*this.scale.x,this.height*this.scale.y,this.scale.z),e=_.createTranslation(-this.rotationOffset.x,-this.rotationOffset.y,0),i=_.createRotationZ(this.rotation),s=_.createTranslation(this.x+this.translation.x+this.rotationOffset.x,this.y+this.translation.y+this.rotationOffset.y,this.translation.z),r=_.multiply;return r(r(r(t,e),i),s)}applyChanges(){if(null===yi(this,ei))throw new TypeError("A model has not been created; cannot apply changes.");gi(this,fi,!1),this.updateModelBuffer()}draw(t,e){if(null!==yi(this,ii)&&null!==yi(this,ei)&&null!==yi(this,si)){if(yi(this,pi))throw new TypeError("The polygon's mesh was modified, but a new model was not created. Make sure to call createModel(graphics).");if(yi(this,fi))throw new TypeError("The polygon's transform was modified, but applyChanges() was never called.");t.begin(yi(this,si)).setVertexBuffer(yi(this,ii).vertexBuffer,yi(this,ei)).setIndexBuffer(yi(this,ii).indexBuffer).setUniform("worldViewProjection",e.wvp.data).drawElements(pt.TRIANGLES,yi(this,ii).totalTriangles,0).end()}}updateModelBuffer(){if(null===yi(this,ei))return;let t=[];t=t.concat(new v(yi(this,ri)+this.translation.x,yi(this,ni)+this.translation.y,yi(this,ai)+this.translation.z).toArray()),t=t.concat(new v(yi(this,hi)*yi(this,ci).x,yi(this,oi)*yi(this,ci).y,yi(this,ci).z).toArray()),t=t.concat(yi(this,di).toArray()),t=t.concat(yi(this,ui)),t=t.concat(yi(this,wi).toArray()),yi(this,ei).setData(t)}}ti=new WeakMap,ei=new WeakMap,ii=new WeakMap,si=new WeakMap,ri=new WeakMap,ni=new WeakMap,ai=new WeakMap,hi=new WeakMap,oi=new WeakMap,li=new WeakMap,ci=new WeakMap,di=new WeakMap,ui=new WeakMap,wi=new WeakMap,pi=new WeakMap,fi=new WeakMap;class Ei extends vi{constructor(t,e,i,s){super(Ve,t,e,i,s)}}class bi extends vi{constructor(t,e,i){super($e,t,e,2*i,2*i),this.radius=i}}const Ti={VERTEX:"\n\t\tuniform mat4 worldViewProjection;\n\n\t\tattribute vec3 a_vertexPosition;\n\t\tattribute vec3 a_translation;\n\t\tattribute vec3 a_scale;\n\t\tattribute vec3 a_rotationOffset;\n\t\tattribute float a_rotation;\n\t\tattribute vec4 a_color;\n\n\t\tvarying lowp vec4 v_color;\n\n\t\tmat4 createTranslation(vec3 translation) {\n\t\t\treturn mat4(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\ttranslation.x, translation.y, translation.z, 1\n\t\t\t);\n\t\t}\n\n\t\tmat4 createScale(vec3 scale) {\n\t\t\treturn mat4(\n\t\t\t\tscale.x, 0, 0, 0,\n\t\t\t\t0, scale.y, 0, 0,\n\t\t\t\t0, 0, scale.z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tmat4 createRotationZ(float theta) {\n\t\t\treturn mat4(\n\t\t\t\tcos(theta), -sin(theta), 0, 0,\n\t\t\t\tsin(theta), cos(theta), 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tmat4 model = createTranslation(a_translation - a_rotationOffset) * createRotationZ(a_rotation) * createTranslation(a_rotationOffset) * createScale(a_scale);\n\t\t\tgl_Position = worldViewProjection * model * vec4(a_vertexPosition, 1);\n\n\t\t\tv_color = a_color;\n\t\t}\n\t",FRAGMENT:"\n\t\tvarying lowp vec4 v_color;\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = v_color;\n\t\t}\n\t"};Object.freeze(Ti);class xi extends ft{constructor(t){super(t,Ti.VERTEX,Ti.FRAGMENT)}}var Mi,_i,ki,Ai=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Si=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class Pi{constructor(t){Mi.set(this,void 0),_i.set(this,void 0),ki.set(this,void 0),Ai(this,Mi,t),Ai(this,_i,null),Ai(this,ki,null)}attachGraphics(t){Ai(this,_i,t),Ai(this,ki,new xi(Si(this,_i)))}createCircle(t,e,i){if(null===Si(this,_i))throw new TypeError("A GraphicsManager has not been attached; cannot create geometry. Make sure to call 'attachGraphics(graphics)' before using a Factory.");if(null===Si(this,ki))throw new Error("Something unexpected happen! Could not create shared PolygonEffect.");if(null===Si(this,Mi).geometryManager)throw new Error("Something unexpected happen! The Theater's GeometryManager was not initialized.");const s=Si(this,Mi).geometryManager.getGeometry("Susurrus_Circle");if(void 0===s)throw new Error("Could not find geometry.");return new bi(t,e,i).attachEffect(Si(this,ki)).attachGeometry(s).createModelBuffer(Si(this,_i))}createQuad(t,e,i,s){if(null===Si(this,_i))throw new TypeError("A GraphicsManager has not been attached; cannot create geometry. Make sure to call 'attachGraphics(graphics)' before using a Factory.");if(null===Si(this,ki))throw new Error("Something unexpected happen! Could not create shared PolygonEffect.");if(null===Si(this,Mi).geometryManager)throw new Error("Something unexpected happen! The Theater's GeometryManager was not initialized.");const r=Si(this,Mi).geometryManager.getGeometry("Susurrus_Square");if(void 0===r)throw new Error("Could not find geometry.");return new Ei(t,e,i,s).attachEffect(Si(this,ki)).attachGeometry(r).createModelBuffer(Si(this,_i))}}Mi=new WeakMap,_i=new WeakMap,ki=new WeakMap;var Wi,Ri,Oi,Li,Ii,zi,Ni,Bi,Di=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Gi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};Wi=new WeakMap,Ri=new WeakMap,Oi=new WeakMap,Li=new WeakMap,Ii=new WeakMap,zi=new WeakMap,Ni=new WeakMap,Bi=new WeakMap;const Ui={BLACK:new wt(0),WHITE:new wt(16777215),RED:new wt(16711680),GREEN:new wt(65280),BLUE:new wt(255)};Object.freeze(Ui);const Ci={SKY_BLUE:new wt(2731519)};Object.freeze(Ci);var ji,Fi,Vi,Xi,$i,qi=Object.freeze({__proto__:null,BASIC:Ui,PICO8:Ci}),Hi=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},Yi=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};const Ki=new K([new q("a_textureCoord",2,H.FLOAT)]),Zi=new K([new q("a_scale",3,H.FLOAT)]);ji=new WeakMap,Fi=new WeakMap,Vi=new WeakMap,Xi=new WeakMap,$i=new WeakMap;const Qi={VERTEX:"\n\t\tuniform mat4 worldViewProjection;\n\n\t\tattribute vec3 a_vertexPosition;\n\t\tattribute vec2 a_textureCoord;\n\t\tattribute vec3 a_scale;\n\n\t\tvarying highp vec2 v_textureCoord;\n\n\t\tmat4 createScale(vec3 scale) {\n\t\t\treturn mat4(\n\t\t\t\t\tscale.x, 0, 0, 0,\n\t\t\t\t\t0, scale.y, 0, 0,\n\t\t\t\t\t0, 0, scale.z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tmat4 model = createScale(a_scale);\n\t\t\tgl_Position = worldViewProjection * model * vec4(a_vertexPosition, 1);\n\n\t\t\tv_textureCoord = a_textureCoord;\n\t\t}\n\t\t",FRAGMENT:"\n\t\tuniform sampler2D sampler;\n\n\t\tvarying highp vec2 v_textureCoord;\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = texture2D(sampler, v_textureCoord);\n\t\t}\n    "};Object.freeze(Qi);class Ji{constructor(t){this.boundary=t}addRange(t){for(let e=0;e<t.length;e++)this.add(t[e])}}var ts,es,is,ss,rs,ns,as=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},hs=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};function os(t,e){let i=t.x,s=t.y;return i=Math.max(e.left,i),i=Math.min(e.right,i),s=Math.max(e.bottom,s),s=Math.min(e.top,s),{x:i,y:s}}ts=new WeakMap,es=new WeakMap,is=new WeakMap,ss=new WeakMap,rs=new WeakMap,ns=new WeakMap;var ls,cs,ds,us,ws,ps,fs,gs,ys=function(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i},ms=function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)};class vs extends Ji{constructor(t,e){super(t),ls.set(this,void 0),cs.set(this,void 0),ds.set(this,void 0),us.set(this,void 0),ws.set(this,void 0),ps.set(this,void 0),fs.set(this,void 0),gs.set(this,void 0),ys(this,ls,e),ys(this,cs,!1),ys(this,ds,0),ys(this,us,new Array(ms(this,ls)).fill(null)),ys(this,ws,null),ys(this,ps,null),ys(this,fs,null),ys(this,gs,null)}query(t){const e=[];if(this.boundary.completelyWithin(t))for(let t=0;t<ms(this,us).length;t++)null!==ms(this,us)[t]&&e.push(ms(this,us)[t].identifier);else for(let i=0;i<ms(this,us).length;i++)null!==ms(this,us)[i]&&t.intersects(ms(this,us)[i].boundary)&&e.push(ms(this,us)[i].identifier);return ms(this,cs)?(e.push(...ms(this,ws).query(t)),e.push(...ms(this,ps).query(t)),e.push(...ms(this,fs).query(t)),e.push(...ms(this,gs).query(t)),e):e}add(t){var e;return!!t.boundary.intersects(this.boundary)&&(ms(this,ds)<ms(this,ls)?(ms(this,us)[(ys(this,ds,1+(e=+ms(this,ds))),e)]=t,!0):(ms(this,cs)||this.subdivide(),!!(ms(this,ws).insert(t)||ms(this,ps).insert(t)||ms(this,fs).insert(t)||ms(this,gs).insert(t))))}clear(){ms(this,cs)&&(ms(this,ws).clear(),ms(this,ps).clear(),ms(this,fs).clear(),ms(this,gs).clear(),ys(this,ws,null),ys(this,ps,null),ys(this,fs,null),ys(this,gs,null)),ys(this,cs,!1),ys(this,ds,0),ms(this,us).fill(null)}subdivide(){const t=.5*this.boundary.width,e=.5*this.boundary.height;ys(this,ws,new vs(new o(this.boundary.x,this.boundary.y,t,e),ms(this,ls))),ys(this,ps,new vs(new o(this.boundary.x+t,this.boundary.y,t,e),ms(this,ls))),ys(this,fs,new vs(new o(this.boundary.x+t,this.boundary.y-e,t,e),ms(this,ls))),ys(this,gs,new vs(new o(this.boundary.x,this.boundary.y-e,t,e),ms(this,ls))),ys(this,cs,!0)}}ls=new WeakMap,cs=new WeakMap,ds=new WeakMap,us=new WeakMap,ws=new WeakMap,ps=new WeakMap,fs=new WeakMap,gs=new WeakMap,t.AttributeElement=q,t.AttributeSchema=K,t.AttributeType=H,t.Bin=class extends Ji{constructor(t,e){super(t),ts.set(this,void 0),es.set(this,void 0),is.set(this,void 0),ss.set(this,void 0),rs.set(this,void 0),ns.set(this,void 0),as(this,ts,new o(s(this.boundary.x,this.boundary.left,this.boundary.right,0,this.boundary.width),s(this.boundary.y,this.boundary.bottom,this.boundary.top,0,this.boundary.height),this.boundary.width,this.boundary.height)),as(this,es,Math.ceil(Math.log2(e))),as(this,is,1<<hs(this,es)),as(this,ss,Math.ceil(this.boundary.width/2**hs(this,es))),as(this,rs,Math.ceil(this.boundary.height/2**hs(this,es))),as(this,ns,new Array(hs(this,rs)*hs(this,ss)).fill(null));for(let t=0;t<hs(this,ns).length;t++)hs(this,ns)[t]=new Set}query(t){const e=[];if(this.boundary.completelyWithin(t)){for(let t=0;t<hs(this,ns).length;t++)for(let i of hs(this,ns)[t])e.push(i);return e}const i=new Set,s=this.getHashIDs(t);for(let t of s)for(let s of hs(this,ns)[t])i.has(s)||(i.add(s),e.push(s));return e}add(t){if(!t.boundary.intersects(this.boundary))return!1;const e=this.getHashIDs(t.boundary);for(let i of e)hs(this,ns)[i].add(t.identifier);return e.size>0}clear(){for(let t=0;t<hs(this,ns).length;t++)hs(this,ns)[t].clear()}getHashIDs(t){const e=new o(s(t.x,this.boundary.left,this.boundary.right,0,this.boundary.width),s(t.y,this.boundary.bottom,this.boundary.top,0,this.boundary.height),t.width,t.height),i=function(t,e){const i=os({x:t.x,y:t.y},e),s=Math.min(t.width,e.right-i.x),r=Math.min(t.height,i.y-e.bottom);return new o(i.x,i.y,s,r)}(e,hs(this,ts)),r=[this.getHash(i.left,i.top),this.getHash(i.right,i.top),this.getHash(i.right,i.bottom),this.getHash(i.left,i.bottom)];if(i.width>hs(this,is)||i.height>hs(this,is)){const t=Math.ceil(i.height/hs(this,is)),s=Math.ceil(i.width/hs(this,is));for(let i=0;i<=t;i++)for(let t=0;t<=s;t++)r.push(this.getHash(e.x+t*hs(this,is),e.y-i*hs(this,is)))}return new Set(r.filter(t=>t>=0))}getHash(t,e){const i=os({x:t,y:e},hs(this,ts)),s=i.x>>hs(this,es),r=i.y>>hs(this,es);return r<0||r>=hs(this,ss)||s<0||s>=hs(this,rs)?-1:hs(this,ss)*r+s}},t.Camera=class{constructor(){W.set(this,void 0),R.set(this,void 0),O.set(this,void 0),L.set(this,void 0),I.set(this,void 0),z.set(this,void 0),N.set(this,void 0),B.set(this,void 0),D.set(this,void 0),G.set(this,void 0),U.set(this,void 0),C.set(this,void 0),V(this,W,v.ZERO),V(this,R,new v(X(this,W).x,X(this,W).y,X(this,W).z+1)),V(this,O,v.UP),V(this,L,0),V(this,I,0),V(this,z,0),V(this,N,0),V(this,B,j.None),V(this,D,_.IDENTITY),V(this,G,_.createLookAt(X(this,R),X(this,W),X(this,O))),V(this,U,_.IDENTITY),V(this,C,_.IDENTITY)}get wvp(){return X(this,C)}get bounds(){return new o(X(this,R).x,X(this,R).y,X(this,z),X(this,N))}createOrthographic(t,e,i,s){return V(this,z,t),V(this,N,e),V(this,L,void 0===i?0:i),V(this,I,void 0===s?0:s),V(this,B,j.Orthographic),V(this,U,_.createOrthographic(X(this,z),X(this,N),X(this,L),X(this,I))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}createPerspective(t,e,i,s){return V(this,z,t),V(this,N,e),V(this,L,void 0===i?0:i),V(this,I,void 0===s?0:s),V(this,B,j.Perspective),V(this,U,_.createPerspective(X(this,z),X(this,N),X(this,L),X(this,I))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setDimensions(t,e){switch(V(this,z,t),V(this,N,e),X(this,B)){case j.Orthographic:V(this,U,_.createOrthographic(X(this,z),X(this,N),X(this,L),X(this,I)));break;case j.Perspective:V(this,U,_.createPerspective(X(this,z),X(this,N),X(this,L),X(this,I)))}return V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setPosition(t,e,i){return X(this,R).x=t,X(this,R).y=e,X(this,R).z=i,V(this,G,_.createLookAt(X(this,R),X(this,W),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setTarget(t,e,i){return X(this,W).x=t,X(this,W).y=e,X(this,W).z=i,V(this,G,_.createLookAt(X(this,R),X(this,W),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setUp(t,e,i){return X(this,O).x=t,X(this,O).y=e,X(this,O).z=i,V(this,G,_.createLookAt(X(this,R),X(this,W),X(this,O))),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}setWorld(t){return V(this,D,t),V(this,C,$(X(this,D),X(this,G),X(this,U))),this}},t.CollisionHelper=f,t.Color=wt,t.DrawMode=pt,t.Effect=ft,t.GeometryData=He,t.IndexBuffer=xt,t.InputHandler=class{constructor(t,e){oe.set(this,void 0),le.set(this,void 0),ce.set(this,void 0),de.set(this,void 0),ue.set(this,void 0),this.playerIndex=e,we(this,oe,new Xt),we(this,le,new he),we(this,ce,new Kt(e)),we(this,de,null),we(this,ue,"keyboard"),pe(this,le).attachElement(t),Object.defineProperty(this,"playerIndex",{writable:!1})}get lastInputType(){return pe(this,ue)}get pointerPosition(){return{x:pe(this,le).x,y:pe(this,le).y}}loadProfile(t){return we(this,de,t),this}pressed(t){if(null===pe(this,de))throw new TypeError("An input profile has not been loaded yet.");const e=pe(this,de).getMapping(t);return void 0!==e&&(0===this.playerIndex&&(pe(this,oe).pressed(e.keys)||pe(this,le).pressed(e.mouseButtons))?(we(this,ue,"keyboard"),!0):!(!pe(this,ce).connected||!pe(this,ce).pressed(e.gamepadButtons))&&(we(this,ue,"gamepad"),!0))}pressing(t){if(null===pe(this,de))throw new TypeError("An input profile has not been loaded yet.");const e=pe(this,de).getMapping(t);return void 0!==e&&(0===this.playerIndex&&(pe(this,oe).pressing(e.keys)||pe(this,le).pressing(e.mouseButtons))?(we(this,ue,"keyboard"),!0):!(!pe(this,ce).connected||!pe(this,ce).pressing(e.gamepadButtons))&&(we(this,ue,"gamepad"),!0))}update(){pe(this,oe).update(),pe(this,le).update(),pe(this,ce).update()}},t.InputProfile=class{constructor(t){be.set(this,void 0),this.name=t,Te(this,be,new Map)}createMapping(t,e,i,s){const r=Me(t);if(xe(this,be).has(r))throw new TypeError("An InputMapping with that name already exists; try a different name.");const n=new Ee(r,e,i,s);return xe(this,be).set(n.name,n),this}getMapping(t){const e=Me(t);if(!xe(this,be).has(e))throw new TypeError("An InputMapping with that name has not been registered.");return xe(this,be).get(e)}remapKeys(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapKeys(e)}remapGamepadButtons(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapGamepadButtons(e)}remapMouseButtons(t,e){var i;null===(i=this.getMapping(t))||void 0===i||i.remapMouseButtons(e)}removeMapping(t){const e=Me(t);if(!xe(this,be).has(e))throw new TypeError("An InputMapping with that name has not been registered.");return xe(this,be).delete(e),this}},t.LineSegment=i,t.MathExt=a,t.Matrix=m,t.Matrix4=_,t.Mesh=Mt,t.Palettes=qi,t.Partitioner=Ji,t.Polygon=vi,t.PolygonEffect=xi,t.Quad=Ei,t.Quadtree=vs,t.Random=class{constructor(t){k.set(this,void 0),A(this,k,P(void 0!==t?Math.floor(t):Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)))}next(){return S(this,k).call(this)}range(t,e){if(e<t)throw new TypeError("The 'maxValue' parameter must be greater than 'minValue' parameter.");return t+Math.floor(S(this,k).call(this)*(e-t))}},t.RandomHelper=F,t.Rectangle=o,t.Scene=class{constructor(t,e){this.name=t,this.theater=e,Object.defineProperty(this,"name",{writable:!1}),Object.defineProperty(this,"theater",{writable:!1})}onEnter(){}onExit(){}},t.SparseSet=Be,t.Sprite=class{constructor(t){ji.set(this,void 0),Fi.set(this,void 0),Vi.set(this,void 0),Xi.set(this,void 0),$i.set(this,void 0),Hi(this,ji,t),Hi(this,Fi,null),Hi(this,Vi,null),Hi(this,Xi,null),Hi(this,$i,null)}attachGeometry(t){return Hi(this,Fi,t),this}attachEffect(t){return Hi(this,Vi,t),this}createTextureBuffer(t){Hi(this,Xi,new Rt(t,Ki,8,Ot.STATIC)),Yi(this,Xi).setData([0,0,1,0,1,1,0,1]);let e=Zi.size;return _e&&(e*=6),Hi(this,$i,new Rt(t,Zi,e,Ot.DYNAMIC,1)),Yi(this,$i).setData([Yi(this,ji).width,Yi(this,ji).height,1]),this}draw(t,e){null!==Yi(this,ji).data&&null!==Yi(this,Fi)&&null!==Yi(this,Vi)&&null!==Yi(this,Xi)&&null!==Yi(this,$i)&&t.begin(Yi(this,Vi)).setVertexBuffer(Yi(this,Fi).vertexBuffer,Yi(this,Xi),Yi(this,$i)).setIndexBuffer(Yi(this,Fi).indexBuffer).setUniform("worldViewProjection",e.wvp.data).setUniform2("sampler").setTexture(Yi(this,ji).data).drawElements(pt.TRIANGLES,Yi(this,Fi).totalTriangles,0).end()}},t.SpriteEffect=class extends ft{constructor(t){super(t,Qi.VERTEX,Qi.FRAGMENT)}},t.Texture2D=Wt,t.Theater=class{constructor(){Wi.set(this,void 0),Ri.set(this,void 0),Oi.set(this,void 0),Li.set(this,void 0),Ii.set(this,void 0),zi.set(this,void 0),Ni.set(this,void 0),Bi.set(this,void 0),Di(this,Wi,null),Di(this,Ri,null),Di(this,Oi,null),Di(this,Li,null),this.smartKeyboard=new Xt,this.smartPointer=new he,this.sceneManager=new Fe,this.factory=new Pi(this),this.loop=!0,Di(this,Ii,!1),Di(this,zi,!1),Di(this,Ni,0),Di(this,Bi,[]),window.addEventListener("mousedown",t=>{null!==Gi(this,Ri)&&Di(this,zi,t.target===Gi(this,Ri))}),Object.defineProperty(this,"smartKeyboard",{writable:!1}),Object.defineProperty(this,"smartPointer",{writable:!1}),Object.defineProperty(this,"sceneManager",{writable:!1}),Object.defineProperty(this,"factory",{writable:!1})}get parent(){return Gi(this,Wi)}get canvas(){return Gi(this,Ri)}get graphics(){return Gi(this,Oi)}get geometryManager(){return Gi(this,Li)}get inFocus(){return Gi(this,zi)}get totalElapsedTime(){return Gi(this,Ni)}get args(){return Gi(this,Bi)}run(t){if(!Gi(this,Ii)){if(void 0!==t){const e=t.trim().split(" ");Di(this,Bi,e)}this.initialize(),Di(this,Ii,!0)}this.main(0)}setParent(t){const e=document.getElementById(t);if(null===e)throw new TypeError(`Could not find an element with an id of '${t}'.`);return Di(this,Wi,e),this}createCanvas(t,e,i){if(null===Gi(this,Wi))throw new Error("A parent element does not exist; a canvas cannot be created. Make sure to call that 'setParent(id)' was called.");Di(this,Ri,document.createElement("canvas")),Gi(this,Ri).id=t,Gi(this,Ri).width=e,Gi(this,Ri).height=i,Gi(this,Wi).appendChild(Gi(this,Ri)),Di(this,Oi,new Tt(function(t){const e=t.getContext("webgl");if(null===e)throw new Error("WebGL is not supported on this device.");return e}(Gi(this,Ri)))),Di(this,Li,new Je(Gi(this,Oi))),this.factory.attachGraphics(Gi(this,Oi)),this.smartPointer.attachElement(Gi(this,Ri))}initialize(){}update(t){this.sceneManager.update(t)}draw(t){if(null===Gi(this,Oi))throw new TypeError("The GraphicsManager has not been instantiated; cannot draw anything. Make sure to call appendCanvas() before rendering anything.");this.sceneManager.draw(Gi(this,Oi),t)}managedUpdate(t){this.smartKeyboard.update(),this.smartPointer.update()}main(t){let e=(t-Gi(this,Ni))/1e3;Number.isNaN(e)&&(e=0),Di(this,Ni,t),this.managedUpdate(e),this.update(e),null!==this.graphics&&this.draw(e),this.loop&&window.requestAnimationFrame(t=>{this.main(t)})}},t.Vector2=h,t.Vector3=v,t.VertexBuffer=Rt,t.VertexUsage=Ot,Object.defineProperty(t,"__esModule",{value:!0})}));
